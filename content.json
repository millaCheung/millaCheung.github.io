{"meta":{"title":"LeehomBlog","subtitle":"","description":"","author":"milla","url":"http://www.milla.club","root":"/"},"pages":[{"title":"","date":"2021-04-05T06:23:03.274Z","updated":"2021-04-05T06:23:03.274Z","comments":true,"path":"about/index.html","permalink":"http://www.milla.club/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-05T06:23:12.442Z","updated":"2021-04-05T06:23:12.442Z","comments":true,"path":"group/index.html","permalink":"http://www.milla.club/group/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker学习","slug":"Docker学习","date":"2021-04-06T15:52:45.000Z","updated":"2021-04-07T15:04:17.482Z","comments":true,"path":"2021/04/06/Docker学习/","link":"","permalink":"http://www.milla.club/2021/04/06/Docker%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Docker 常用命令帮助命令123docker version # 显示docker版本信息docker info # 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help # 帮助命令 帮助文档地址：https://docs.docker.com/reference/ 镜像命令docker images 查看本地所有主机上的镜像 1234567891011121314[root@izbp11tm4pvghonrtfzq17z docker]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest d1165f221234 3 weeks ago 13.3kB# 解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的idCREATED 镜像的创建时间SIZE 镜像的大小# 可选项 -a, --all Show all images (default hides intermediate images) -q, --quiet Only show image IDs docker search 搜索镜像 123456789101112[root@izbp11tm4pvghonrtfzq17z docker]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10680 [OK] mariadb MariaDB Server is a high performing open sou… 4011 [OK] # 可选项，通过收藏来过滤 --filter=STARS=3000 搜索出来的镜像就是STARS大于3000的 [root@izbp11tm4pvghonrtfzq17z docker]# docker search mysql --filter=STARS=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 10680 [OK] mariadb MariaDB Server is a high performing open sou… 4011 [OK] docker pull 下载镜像 1234567891011121314151617181920212223242526272829303132333435363738394041# 下载镜像 docker pull 镜像名[:tag][root@izbp11tm4pvghonrtfzq17z docker]# docker pull mysqlUsing default tag: latest # 如果不写 tag，默认就是 latestlatest: Pulling from library/mysqla076a628af6f: Pull complete # 分层下载，docker image的核心 联合文件系统f6c208f3f991: Pull complete 88a9455a9165: Pull complete 406c9b8427c6: Pull complete 7c88599c0b25: Pull complete 25b5c6debdaf: Pull complete 43a5816f1617: Pull complete 1a8c919e89bf: Pull complete 9f3cf4bd1a07: Pull complete 80539cea118d: Pull complete 201b3cad54ce: Pull complete 944ba37e1c06: Pull complete Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c # 签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 等价于它docker pull mysqldocker pull docker.io/library/mysql:latest# 指定版本下载[root@izbp11tm4pvghonrtfzq17z docker]# docker pull mysql:5.75.7: Pulling from library/mysqla076a628af6f: Already exists f6c208f3f991: Already exists 88a9455a9165: Already exists 406c9b8427c6: Already exists 7c88599c0b25: Already exists 25b5c6debdaf: Already exists 43a5816f1617: Already exists 1831ac1245f4: Pull complete 37677b8c1f79: Pull complete 27e4ac3b0f6e: Pull complete 7227baa8c445: Pull complete Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808dfStatus: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像 123[root@izbp11tm4pvghonrtfzq17z docker]# docker rmi -f 镜像id # 删除指定的镜像[root@izbp11tm4pvghonrtfzq17z docker]# docker rmi -f 镜像id 镜像id 镜像id # 删除多个镜像[root@izbp11tm4pvghonrtfzq17z docker]# docker rmi -f $(docker images -qa) # 删除全部镜像 容器命令说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习 1docker pull centos 新建容器并启动 123456789101112131415161718192021docker run [可选参数] image# 参数说明--name=&quot;Name&quot; 容器名字 tomcat1 tomcat2，用来区分容器-d 后台方式运行-it 使用交互方式运行，进入容器查看内容-p 指定容器的端口 -p 8080:8080 -p ip:主机端口:容器端口 -p 主机端口:容器端口（常用） -p 容器端口 容器端口-P 随机指定端口# 测试，启动并进入容器[root@izbp11tm4pvghonrtfzq17z docker]# docker run -it centos /bin/bash[root@2c46534669b8 /]# ls bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 从容器中退回主机[root@2c46534669b8 /]# exitexit 列出所有运行的容器 1234567891011121314# docker ps 命令 # 列出当前正在运行的容器-a # 列出当前正在运行的容器+带出历史运行过的容器-n=? # 显示最近创建的容器-q # 只显示容器的编号[root@izbp11tm4pvghonrtfzq17z docker]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[root@izbp11tm4pvghonrtfzq17z docker]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2c46534669b8 centos &quot;/bin/bash&quot; 4 minutes ago Exited (0) 2 minutes ago loving_cohenf8ee4e64568f d1165f221234 &quot;/hello&quot; 2 hours ago Exited (0) 2 hours ago keen_black094ee2c31714 d1165f221234 &quot;/hello&quot; 3 hours ago Exited (0) 3 hours ago inspiring_babbage 退出容器 12exit # 直接容器停止并退出Ctrl + p + q # 容器不停止退出 删除容器 123docker rm 容器id # 删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -fdocker rm -f $(docker ps -aq) # 删除所有的容器docker ps -a -q | xargs docker rm # 删除所有的容器 启动和停止容器的操作 1234docker start 容器id # 启动容器docker restart 容器id # 重启容器docker stop 容器id # 停止当前正在运行的容器docker kill 容器id # 强制停止当前容器 常用其它命令 后台启动容器 123456# 命令 docker run -d 镜像名[root@izbp11tm4pvghonrtfzq17z /]# docker run -d centos# 问题docker ps，发现 centos 停止# 常见的坑，docker 容器使用后台运行，就必须要有一个前台进程，docker 发现没有应用，就会自动停止# nginx，容器启动后，发现自己没有提供服务，就会立刻停止 查看日志 1234567891011121314docker logs -f -t --tail 容器，没有日志# 自己编写一段shell脚本[root@izbp11tm4pvghonrtfzq17z /]# docker run -d centos /bin/sh -c &quot;while true;do echo milla;sleep 2;done&quot;[root@izbp11tm4pvghonrtfzq17z /]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4fbb65c2f215 centos &quot;/bin/sh -c &#x27;while t…&quot; 5 seconds ago Up 5 seconds bold_banach# 查看日志-tf # 显示日志--tail number # 要显示日志条数[root@izbp11tm4pvghonrtfzq17z /]# docker logs -tf --tail 10 4fbb65c2f215[root@izbp11tm4pvghonrtfzq17z /]# docker logs -tf 4fbb65c2f215 查看容器中的进程信息 12345# 命令 docker top 容器id[root@izbp11tm4pvghonrtfzq17z /]# docker top 4fbb65c2f215UID PID PPID C STIME TTY root 8294 8255 0 22:48 ? root 8805 8294 0 23:00 ? 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209# 命令 docker inspect 容器id[root@izbp11tm4pvghonrtfzq17z /]# docker inspect 4fbb65c2f215[ &#123; &quot;Id&quot;: &quot;4fbb65c2f215288029d27376c215de7255ba72044ffbbbdd9668de4f19b1cff9&quot;, &quot;Created&quot;: &quot;2021-04-01T14:48:13.251805266Z&quot;, &quot;Path&quot;: &quot;/bin/sh&quot;, &quot;Args&quot;: [ &quot;-c&quot;, &quot;while true;do echo milla;sleep 2;done&quot; ], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 8294, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2021-04-01T14:48:13.634451808Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/4fbb65c2f215288029d27376c215de7255ba72044ffbbbdd9668de4f19b1cff9/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/4fbb65c2f215288029d27376c215de7255ba72044ffbbbdd9668de4f19b1cff9/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/4fbb65c2f215288029d27376c215de7255ba72044ffbbbdd9668de4f19b1cff9/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/4fbb65c2f215288029d27376c215de7255ba72044ffbbbdd9668de4f19b1cff9/4fbb65c2f215288029d27376c215de7255ba72044ffbbbdd9668de4f19b1cff9-json.log&quot;, &quot;Name&quot;: &quot;/bold_banach&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;CgroupnsMode&quot;: &quot;host&quot;, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/5856cd6e6cac3df34272c29e926f99438c13d80f43a4058d74418d0853fe2d4f-init/diff:/var/lib/docker/overlay2/fe88001470606eaa1b94400a5b658905f581ab7c289ec8cecf5bbd4176999d6b/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/5856cd6e6cac3df34272c29e926f99438c13d80f43a4058d74418d0853fe2d4f/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/5856cd6e6cac3df34272c29e926f99438c13d80f43a4058d74418d0853fe2d4f/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/5856cd6e6cac3df34272c29e926f99438c13d80f43a4058d74418d0853fe2d4f/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;4fbb65c2f215&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;while true;do echo milla;sleep 2;done&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;c34acd28a9404fb62a2e1dfa6fce49888f31a395ec27cf9c092894dd4b99f90d&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/c34acd28a940&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;40045d4858fcd339b17dd03135b055cf4a8bd08a9b48f1e3860fb3bf9be015f8&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;e7a0064379362e134aced403c3e2bc73db70bd98a2830787f45a158368323502&quot;, &quot;EndpointID&quot;: &quot;40045d4858fcd339b17dd03135b055cf4a8bd08a9b48f1e3860fb3bf9be015f8&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;] 进入当前正在运行的容器 12345678910111213141516171819202122232425# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置# 命令 方式一docker exec -it 容器it bashShell# 测试[root@izbp11tm4pvghonrtfzq17z /]# docker exec -it 4fbb65c2f215 /bin/bash[root@4fbb65c2f215 /]# lsbin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var[root@4fbb65c2f215 /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 14:48 ? 00:00:00 /bin/sh -c while true;do echo milla;sleep 2;doneroot 692 0 0 15:11 pts/0 00:00:00 /bin/bashroot 711 1 0 15:11 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 2root 712 692 0 15:11 pts/0 00:00:00 ps -ef[root@4fbb65c2f215 /]# # 方式二docker attach 容器id# 测试[root@izbp11tm4pvghonrtfzq17z /]# docker attach 4fbb65c2f215正在执行当前的代码...# docker exec # 进入容器后开启一个新的终端，可以在里面操作（常用）# docker attach # 进入容器正在执行的终端，不会启动新的进程 从容器内拷贝文件到主机上 1234docker cp 容器id:容器内路径 目的主机路径[root@izbp11tm4pvghonrtfzq17z home]# docker cp bcdf87e20f3b:/home/test.java /home# 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步 小结 作业练习 Docker 安装 Nginx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 1.搜索镜像 search# 2.下载镜像 pull # 3.运行测试 [root@izbp11tm4pvghonrtfzq17z leehom]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest f6d0b4767a6c 2 months ago 133MBcentos latest 300e315adb2f 3 months ago 209MB# -d 后台运行# --name 给容器命名# -p 宿主机端口:容器内部端口[root@izbp11tm4pvghonrtfzq17z leehom]# docker run -d --name nginx01 -p 3344:80 nginx3e2fdd3d1d91d50059ab0c5e29b8407385838801bf69493e94bd1db84c419404[root@izbp11tm4pvghonrtfzq17z leehom]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3e2fdd3d1d91 nginx &quot;/docker-entrypoint.…&quot; 8 seconds ago Up 7 seconds 0.0.0.0:3344-&gt;80/tcp nginx01[root@izbp11tm4pvghonrtfzq17z leehom]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;# 进入容器[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it nginx01 /bin/bashroot@3e2fdd3d1d91:/# whereis nginxnginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginxroot@3e2fdd3d1d91:/# cd /etc/nginx/root@3e2fdd3d1d91:/etc/nginx# lsconf.d fastcgi_params koi-utf koi-win mime.types modules nginx.conf scgi_params uwsgi_params win-utf Docker 安装 Tomcat 1234567891011121314151617181920# 官方的使用docker run -it --rm tomcat:9.0# 之前的启动均为后台，停止容器后，容器还可以查到 docker run -it --rm，一般用来测试，用完就删除# 下载再启动docker pull tomcat# 启动运行docker run -d -ip 3345:8080 --name tomcat01 tomcat# 测试访问没有问题[root@izbp11tm4pvghonrtfzq17z leehom]# docker run -d -p 3345:8080 --name tomcat01 tomcat523834660d43deb93c0450ccf71eded487aa38a0cfba8b79c2c4057312f33265# 进入容器[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat01 /bin/bash# 发现问题：1.linux命令减少 2.没有webapps 阿里云镜像的原因。默认是最小的镜像，所以不必要的都剔除# 保证最小可运行环境 Docker 部署 es + kibana 1234567891011121314151617181920212223242526272829303132333435# es 暴露的端口很多# es 十分耗内存# es 的数据一般需要放置到安全目录！挂载# --net somenetwork 网络配置# 启动docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:tag# docker stats 查看cpu的状态 # es 耗内存# 增加内存限制，修改配置文件，-e 环境配置修改docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2# 查看 docker stats[root@izbp11tm4pvghonrtfzq17z leehom]# curl localhost:9200&#123; &quot;name&quot; : &quot;efd0aed936ea&quot;, &quot;cluster_name&quot; : &quot;docker-cluster&quot;, &quot;cluster_uuid&quot; : &quot;MeGd_2w_TiqdUpNhosPRGQ&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;7.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;docker&quot;, &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;, &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;8.4.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 可视化 portainer 1docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer Rancher(CI/CD) 什么是 portainer？ Docker图形化界面管理工具，提供一个后台面板供我们操作 1docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 访问测试：外网 http://47.111.117.142:8088/ Docker 镜像讲解镜像是什么镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 所有的应用，直接打包docker镜像，就可以直接运行。 如何得到镜像： 远程仓库下载 拷贝他人 自己制作镜像 DockerFile Docker 镜像加载原理 UnionFS（联合文件系统） UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directions into a single virctual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 Docker 镜像加载原理 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS bootfs（boot file system）主要包含bootloader和kernal，bootloader主要是引导加载kernal，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，CentOS等。 对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以，因为底层直接用Host的kernal，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。 分层理解 分层的镜像 我们可以去下载一个镜像，注意观察镜像下载的日志输出，可以看到是一层一层的在下载 思考：为什么Docker镜像要采用这种分层的结构呢？ 最大的好处，资源共享。比如多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。 查看镜像分层的方式可以通过docker image inspect命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125[root@izbp11tm4pvghonrtfzq17z leehom]# docker image inspect tomcat[ &#123; &quot;Id&quot;: &quot;sha256:040bdb29ab375db2a8de090070dcbee19d43f609385a934c3f2b423e515f57bb&quot;, &quot;RepoTags&quot;: [ &quot;tomcat:latest&quot; ], &quot;RepoDigests&quot;: [ &quot;tomcat@sha256:94cc18203335e400dbafcd0633f33c53663b1c1012a13bcad58cced9cd9d1305&quot; ], &quot;Parent&quot;: &quot;&quot;, &quot;Comment&quot;: &quot;&quot;, &quot;Created&quot;: &quot;2021-01-13T08:25:41.687056149Z&quot;, &quot;Container&quot;: &quot;c0e0ce470360f568d9310e6a82707459a3a62737a69339a8ddcff56bd10a5623&quot;, &quot;ContainerConfig&quot;: &#123; &quot;Hostname&quot;: &quot;c0e0ce470360&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: &#123; &quot;8080/tcp&quot;: &#123;&#125; &#125;, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/tomcat/bin:/usr/local/openjdk-11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;LANG=C.UTF-8&quot;, &quot;JAVA_HOME=/usr/local/openjdk-11&quot;, &quot;JAVA_VERSION=11.0.9.1&quot;, &quot;CATALINA_HOME=/usr/local/tomcat&quot;, &quot;TOMCAT_NATIVE_LIBDIR=/usr/local/tomcat/native-jni-lib&quot;, &quot;LD_LIBRARY_PATH=/usr/local/tomcat/native-jni-lib&quot;, &quot;GPG_KEYS=05AB33110949707C93A279E3D3EFE6B686867BA6 07E48665A34DCAFAE522E5E6266191C37C037D42 47309207D818FFD8DCD3F83F1931D684307A10A5 541FBE7D8F78B25E055DDEE13C370389288584E7 61B832AC2F1C5A90F0F9B00A1C506407564C17A3 79F7026C690BAA50B92CD8B66A3AD3F4F22C4FED 9BA44C2621385CB966EBA586F72C284D731FABEE A27677289986DB50844682F8ACB77FC2E86E29AC A9C5DF4D22E99998D9875A5110C01C5A2F6059E7 DCFD35E0BF8CA7344752DE8B6FB21E8933C60243 F3A04C595DB5B6A5F1ECA43E3B7BBB100D811BBE F7DA48BB64BCB84ECBA7EE6935CD23C10D498E23&quot;, &quot;TOMCAT_MAJOR=9&quot;, &quot;TOMCAT_VERSION=9.0.41&quot;, &quot;TOMCAT_SHA512=b6450e590a37c5bccf049b1176c441f0964796995e80d4c7c7d9fb74f9ad817107c303b6b83ed3d71c9251b2b8acf334b90a4abdf9deea122e338643cece0766&quot; ], &quot;Cmd&quot;: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;#(nop) &quot;, &quot;CMD [\\&quot;catalina.sh\\&quot; \\&quot;run\\&quot;]&quot; ], &quot;Image&quot;: &quot;sha256:1970da43b48127fd9bb3e865979ea111f73f0b134e9e5ed4e37b5f1dd6d26aae&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/usr/local/tomcat&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123;&#125; &#125;, &quot;DockerVersion&quot;: &quot;19.03.12&quot;, &quot;Author&quot;: &quot;&quot;, &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;ExposedPorts&quot;: &#123; &quot;8080/tcp&quot;: &#123;&#125; &#125;, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/tomcat/bin:/usr/local/openjdk-11/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;LANG=C.UTF-8&quot;, &quot;JAVA_HOME=/usr/local/openjdk-11&quot;, &quot;JAVA_VERSION=11.0.9.1&quot;, &quot;CATALINA_HOME=/usr/local/tomcat&quot;, &quot;TOMCAT_NATIVE_LIBDIR=/usr/local/tomcat/native-jni-lib&quot;, &quot;LD_LIBRARY_PATH=/usr/local/tomcat/native-jni-lib&quot;, &quot;GPG_KEYS=05AB33110949707C93A279E3D3EFE6B686867BA6 07E48665A34DCAFAE522E5E6266191C37C037D42 47309207D818FFD8DCD3F83F1931D684307A10A5 541FBE7D8F78B25E055DDEE13C370389288584E7 61B832AC2F1C5A90F0F9B00A1C506407564C17A3 79F7026C690BAA50B92CD8B66A3AD3F4F22C4FED 9BA44C2621385CB966EBA586F72C284D731FABEE A27677289986DB50844682F8ACB77FC2E86E29AC A9C5DF4D22E99998D9875A5110C01C5A2F6059E7 DCFD35E0BF8CA7344752DE8B6FB21E8933C60243 F3A04C595DB5B6A5F1ECA43E3B7BBB100D811BBE F7DA48BB64BCB84ECBA7EE6935CD23C10D498E23&quot;, &quot;TOMCAT_MAJOR=9&quot;, &quot;TOMCAT_VERSION=9.0.41&quot;, &quot;TOMCAT_SHA512=b6450e590a37c5bccf049b1176c441f0964796995e80d4c7c7d9fb74f9ad817107c303b6b83ed3d71c9251b2b8acf334b90a4abdf9deea122e338643cece0766&quot; ], &quot;Cmd&quot;: [ &quot;catalina.sh&quot;, &quot;run&quot; ], &quot;Image&quot;: &quot;sha256:1970da43b48127fd9bb3e865979ea111f73f0b134e9e5ed4e37b5f1dd6d26aae&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;/usr/local/tomcat&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: null &#125;, &quot;Architecture&quot;: &quot;amd64&quot;, &quot;Os&quot;: &quot;linux&quot;, &quot;Size&quot;: 648670193, &quot;VirtualSize&quot;: 648670193, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/6be815495c5b8e50bf585ced0ff44b8cb7fe79412cf061b26457875fe4d9d732/diff:/var/lib/docker/overlay2/335e058247e557d0582f51c2399af3c96f080cc39d373d5586310586f71ecfb4/diff:/var/lib/docker/overlay2/78d611b3099b748c6a66c86651304343803710b8f0d6dc2ea708e3d7f31d4278/diff:/var/lib/docker/overlay2/2912b336c34af814dfe010c0514c6365be3c523035245085273d656b2c54616a/diff:/var/lib/docker/overlay2/ad4c533f2c7b579630edcb75fd5ad8273d66dd86572782f346d14efc5b27897a/diff:/var/lib/docker/overlay2/9c6c575a49abb0f27770fde72e80e51d7b5169415bab2df486efe22492054325/diff:/var/lib/docker/overlay2/16c51fb86d01fea1c6b341e6aa50af1df025ee3b185b6d7156864d050bcf183a/diff:/var/lib/docker/overlay2/ae9bb405669c82927db85bff8a3c587e34e4684c2404676daa2c9523318a41ba/diff:/var/lib/docker/overlay2/101690782b2e4ee798c9cc71851b4ef7c5e6f354375b29b12b6a6b8d021f497f/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/5bf74a1aacdc6202bef24977782597af1f5618a9222713740c52b4523a85b3c8/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/5bf74a1aacdc6202bef24977782597af1f5618a9222713740c52b4523a85b3c8/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/5bf74a1aacdc6202bef24977782597af1f5618a9222713740c52b4523a85b3c8/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;RootFS&quot;: &#123; &quot;Type&quot;: &quot;layers&quot;, &quot;Layers&quot;: [ &quot;sha256:4762552ad7d851a9901571428078281985074e5ddb806979dd7ad24748db4ca0&quot;, &quot;sha256:a1f2f42922b1d3aa948f2569adebb37129941e889f13b96823a5e2aa8ecc1a8f&quot;, &quot;sha256:ef9a7b8862f4797ec08f3733ab9fc2a08c51f44e5561b087eb10a6e442599760&quot;, &quot;sha256:aa7af8a465c6b600b7151db82799f757d0029c7fb9f170faaffdc40080c525c5&quot;, &quot;sha256:7496c5e8691b7de622ad5c1e0f9b300df55e923b960fc75e7b7cf1a297a36da8&quot;, &quot;sha256:7a9b35031285d77ce1d4e73b9eabb0a8f204b0729c3f4c342bca4e57b73fbae1&quot;, &quot;sha256:500f722b156b012903f8a0af13cfb2a8521be6b2126071f4330714b6fa5bd9d7&quot;, &quot;sha256:8e2e6f2527c7c2e81725a0d539a04281d8a32b26bf2ca57fe5f5ffe20862625d&quot;, &quot;sha256:c9132b9a3fc8c30239edb774bdf01b252e1cbe945c3994e4fa12929cc93831d4&quot;, &quot;sha256:9ddc8cd8299b64510aee4f540827bf2c5cf326aa73fdd47a599a1ee0d9a8c224&quot; ] &#125;, &quot;Metadata&quot;: &#123; &quot;LastTagTime&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125; &#125;] 理解： 所有的Docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前镜像之上，创建新的镜像层。 举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。 特点 Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部 这一层就是我们通常说的容器层，容器之下的都叫镜像层 commit 镜像1234docker commit 提交容器成为一个新的副本# 命令docker commit -m=&quot;提交的描述信息&quot; -a=&quot;author&quot; 容器id 目标镜像名:[TAG] 实战测试 123456789101112131415# 启动一个默认的tomcat# 默认的tomcat中没有webapps应用# 拷贝文件到webapps# 将操作后的容器通过commit提交为一个镜像[root@izbp11tm4pvghonrtfzq17z leehom]# docker commit -a=&quot;leehom&quot; -m=&quot;add webapps application&quot; b04a60af5208 tomcat02:1.0sha256:f9448739f0f638683f8df37d07a658cba8c11d3a1a5ba9b30b806fe396ebb0bc[root@izbp11tm4pvghonrtfzq17z leehom]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtomcat02 1.0 f9448739f0f6 6 seconds ago 654MBtomcat latest 040bdb29ab37 2 months ago 649MBnginx latest f6d0b4767a6c 2 months ago 133MBcentos latest 300e315adb2f 3 months ago 209MBportainer/portainer latest 62771b0b9b09 8 months ago 79.1MBelasticsearch 7.6.2 f29a1ee41030 12 months ago 791MBelasticsearch latest 5acf0e8da90b 2 years ago 486MB 容器数据卷什么是容器数据卷docker 的理念回顾 将应用和环境打包成一个镜像 数据？如果数据都在容器中，那么容器删除，数据就会丢失。需求：数据持久化 使用数据卷（volume） 方式一：直接使用命令来挂载 -v 123456789101112131415161718dicker run -it -v 主机目录:容器内目录 -p 主机端口:容器内目录 # 测试[root@izbp11tm4pvghonrtfzq17z home]# docker run -it -v /home/test:/home centos /bin/bash# docker inspect 容器id，查看挂载信息&quot;Mounts&quot;: [ &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/test&quot;, &quot;Destination&quot;: &quot;/home&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;rprivate&quot; &#125;]# 双向绑定 优点：我们以后修改数据只需要在本地修改即可，容器内会自动同步 实战：安装MySQL思考：MySQL 的数据持久化问题 123456789101112131415161718# 获取镜像[root@izbp11tm4pvghonrtfzq17z home]docker pull mysql# 运行容器，数据挂载 # 安装启动mysql，配置密码$ docker run --privileged --name some-docker -d \\ --network some-network --network-alias docker \\ -e DOCKER_TLS_CERTDIR=/certs \\ -v some-docker-certs-ca:/certs/ca \\ -v some-docker-certs-client:/certs/client \\ docker:dind # 启动mysql-d 后台运行-p 端口映射-v 卷挂载-e 环境配置--name 容器名称[root@izbp11tm4pvghonrtfzq17z home]# docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql 具名和匿名挂载12345678910111213141516171819202122232425262728293031# 匿名挂载-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx# 查看所有卷的情况[root@izbp11tm4pvghonrtfzq17z data]# docker volume lsDRIVER VOLUME NAMElocal 564a2a08cae29b8658b437c3d4ae356d8dce0cfa2d6b4a0bf6d7da38d4973bfa# 匿名挂载，我们在 -v 只写了容器内的路径，没有写容器外的路径# 具名挂载[root@izbp11tm4pvghonrtfzq17z leehom]# docker run -d -P --name nginx03 -v hava-name:/etc/nginx nginx[root@izbp11tm4pvghonrtfzq17z leehom]# docker volume lsDRIVER VOLUME NAMElocal hava-name# 通过 -v 卷名：容器内路径# 查看卷[root@izbp11tm4pvghonrtfzq17z leehom]# docker volume inspect hava-name[ &#123; &quot;CreatedAt&quot;: &quot;2021-04-04T13:03:35+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: null, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/hava-name/_data&quot;, &quot;Name&quot;: &quot;hava-name&quot;, &quot;Options&quot;: null, &quot;Scope&quot;: &quot;local&quot; &#125;] 我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用的是具名挂载 1234# 如何确定是具名挂载还是匿名挂载，还是指定路径挂载-v 容器内路径 # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /宿主机路径:容器内路径 # 指定路径挂载 拓展： 123456789# 通过 -v 容器内路径:ro rw 改变读写权限ro readonlyrw readwrite# 一旦设置了这个容器权限，容器对我们挂载出来的内容就有限定了[root@izbp11tm4pvghonrtfzq17z leehom]# docker run -d -P --name nginx03 -v hava-name:/etc/nginx:ro nginx[root@izbp11tm4pvghonrtfzq17z leehom]# docker run -d -P --name nginx03 -v hava-name:/etc/nginx:rw nginx# ro 只能通过宿主机进行操作，容器内无法操作 初识 DockerFileDockerfile就是用来构建docker镜像的构建文件 12345678910111213141516171819202122232425262728# 创建一个dockerfile文件，建议名称dockerfile# 文件内容 指令（大写） 参数FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;]CMD echo &quot;----end----&quot;CMD /bin/bash# 这里的每个镜像，就是镜像的一层[root@izbp11tm4pvghonrtfzq17z docker-test-volume]# docker build -f dockerfile -t leehom/centos .Sending build context to Docker daemon 2.048kBStep 1/4 : FROM centos ---&gt; 300e315adb2fStep 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume02&quot;] ---&gt; Running in 46a25c996864Removing intermediate container 46a25c996864 ---&gt; 840f9c86049dStep 3/4 : CMD echo &quot;----end----&quot; ---&gt; Running in 8ac34e3bbb8bRemoving intermediate container 8ac34e3bbb8b ---&gt; e80dc1082cb6Step 4/4 : CMD /bin/bash ---&gt; Running in fe5ff793d737Removing intermediate container fe5ff793d737 ---&gt; bd4405ba928bSuccessfully built bd4405ba928bSuccessfully tagged leehom/centos:latest 数据卷容器多个mysql同步数据 1[root@izbp11tm4pvghonrtfzq17z docker-test-volume]# docker run -it --name docker02 --volumes-from docker01 leehom/centos 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止 DockerFileDockerFile 介绍dockerfile 是用来构建docker镜像的文件，命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build构建成为一个镜像 docker run 运行镜像 docker push 发布镜像（DockerHub、阿里云镜像仓库） DockerFile构建过程基础知识： 每个保留关键字（指令）都必须是大写字母 指令从上到下顺序执行 # 表示注释 每一个指令都会创建提交一个新的镜像层，并且提交 dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单 docker镜像逐渐称为一个企业交付的标准，必须要掌握 步骤：开发，部署，运维 DockerFile：构建文件，定义了一切的步骤，源代码 DokcerImages：通过DockerFile构建生成的镜像，最终要发布和运行的产品 Docker容器：容器就是镜像运行起来提供服务器 DockerFile的指令123456789101112FROM # 基础镜像，一切从这里开始构建 centosMAINTAINER # 镜像是谁写的，姓名+邮箱RUN # 镜像构建的时候需要运行的命令ADD # 步骤：tomcat镜像，这个tomcat压缩包，添加内容WORKDIR # 镜像的工作目录 VOLUME # 挂载目录EXPOSE # 暴露端口配置CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD # 当构建一个被继承DockerFile，这个时候就会运行ONBUILD的指令。触发指令。COPY # 类似ADD，将我们的文件拷贝到镜像中ENV # 构建的时候，设置环境变量 实战测试DokcerHub 中 99% 的镜像都是从这个基础镜像过来的 FROM scratch，然后配置需要的软件和配置来进行构建 创建一个自己的centos 12345678910111213141516171819202122232425262728293031323334353637383940414243# 1.编写dockerfile的文件FROM centosMAINTAINER milla&lt;1640111308@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vim RUN yun -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;----end----&quot;CMD /bin/bash# 2.通过这个文件构建镜像# 命令 docker build -f dickerfile文件路径 -t 镜像名[:tag]Successfully built 70bce6272810Successfully tagged mycentos:latest# 3.测试运行[root@izbp11tm4pvghonrtfzq17z dockerfile]# docker run -it mycentos[root@8bbc68b487ee local]# pwd/usr/local[root@8bbc68b487ee local]# vim test[root@8bbc68b487ee local]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.17.0.3 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:03 txqueuelen 0 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 我们可以列出本地进行的变更历史 1234567891011121314[root@izbp11tm4pvghonrtfzq17z dockerfile]# docker history 70bce6272810IMAGE CREATED CREATED BY SIZE COMMENT70bce6272810 10 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin… 0B 6b084c2d9377 10 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo… 0B 16ec5a4812cd 10 minutes ago /bin/sh -c #(nop) CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo… 0B e8edfdadabc6 10 minutes ago /bin/sh -c #(nop) EXPOSE 80 0B 731fa601ffc7 10 minutes ago /bin/sh -c yum -y install net-tools 14.3MB cb5759d9936a 11 minutes ago /bin/sh -c yum -y install vim 58MB e102ada4a25f 11 minutes ago /bin/sh -c #(nop) WORKDIR /usr/local 0B 03449c03ded8 11 minutes ago /bin/sh -c #(nop) ENV MYPATH=/usr/local 0B 48313dac59f6 11 minutes ago /bin/sh -c #(nop) MAINTAINER milla&lt;16401113… 0B 300e315adb2f 3 months ago /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;] 0B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc… 0B &lt;missing&gt; 3 months ago /bin/sh -c #(nop) ADD file:bd7a2aed6ede423b7… 209MB 我们平时拿到一个镜像，可以研究一下它是怎么做到的 CMD 和 ENTRYPOINT 区别 12CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 测试CMD 1234567891011121314151617181920212223242526272829303132333435363738# 1.编写dockerfile文件[root@izbp11tm4pvghonrtfzq17z dockerfile]# vim dockerfile-cmd-testFROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]# 2.构建镜像[root@izbp11tm4pvghonrtfzq17z dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .# 3.run运行，ls -a 命令生效[root@izbp11tm4pvghonrtfzq17z dockerfile]# docker run cmdtest ....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 想追加一个命令 -l ls -al[root@izbp11tm4pvghonrtfzq17z dockerfile]# docker run cmdtest -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:367: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.# cmd 的情况下，-l 替换了 CMD [&quot;ls&quot;, &quot;-a&quot;]命令，-l 不是命令，所以报错 测试ENTRYPOINT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[root@izbp11tm4pvghonrtfzq17z dockerfile]# vi dockerfile-entrypoint-testFROM centosENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;][root@izbp11tm4pvghonrtfzq17z dockerfile]# docker build -f dockerfile-entrypoint-test -t entrypointtest .[root@izbp11tm4pvghonrtfzq17z dockerfile]# docker run entrypointtest....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar# 追加命令，是直接拼接到ENTRYPOINT命令的后面[root@izbp11tm4pvghonrtfzq17z dockerfile]# docker run entrypointtest -ltotal 56drwxr-xr-x 1 root root 4096 Apr 6 13:13 .drwxr-xr-x 1 root root 4096 Apr 6 13:13 ..-rwxr-xr-x 1 root root 0 Apr 6 13:13 .dockerenvlrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -&gt; usr/bindrwxr-xr-x 5 root root 340 Apr 6 13:13 devdrwxr-xr-x 1 root root 4096 Apr 6 13:13 etcdrwxr-xr-x 2 root root 4096 Nov 3 15:22 homelrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -&gt; usr/liblrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -&gt; usr/lib64drwx------ 2 root root 4096 Dec 4 17:37 lost+founddrwxr-xr-x 2 root root 4096 Nov 3 15:22 mediadrwxr-xr-x 2 root root 4096 Nov 3 15:22 mntdrwxr-xr-x 2 root root 4096 Nov 3 15:22 optdr-xr-xr-x 93 root root 0 Apr 6 13:13 procdr-xr-x--- 2 root root 4096 Dec 4 17:37 rootdrwxr-xr-x 11 root root 4096 Dec 4 17:37 runlrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -&gt; usr/sbindrwxr-xr-x 2 root root 4096 Nov 3 15:22 srvdr-xr-xr-x 13 root root 0 Apr 6 13:13 sysdrwxrwxrwt 7 root root 4096 Dec 4 17:37 tmpdrwxr-xr-x 12 root root 4096 Dec 4 17:37 usrdrwxr-xr-x 20 root root 4096 Dec 4 17:37 var 实战：Tomcat 镜像 准备镜像文件 tomcat 压缩包，jdk的压缩包 12[root@izbp11tm4pvghonrtfzq17z tomcat]# lsapache-tomcat-10.0.4.tar.gz jdk-16_linux-x64_bin.tar.gz 编写dockerfile文件，官方命名 Dockerfile，build 会自动寻找这个文件，不需要-f指定 12345678910111213141516171819202122FROM centosMAINTAINER milla&lt;1640111308@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-16_linux-x64_bin.tar.gz /usr/local/ADD apache-tomcat-10.0.4.tar.gz /usr/local/RUN yum -y install vimENV MYPATH /usr/localWORKDIR $MYPATHENV JAVA_HOME /usr/local/jdk-16ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATLINA_HOME /usr/local/apache-tomcat-10.0.4ENV CATALINA_BASH /usr/local/apache-tomcat-10.0.4ENV PATH $PATH:$JAVA_HOME/bin:$CATLINA_HOME/lib:$CATLINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-10.0.4/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-10.0.4/bin/logs/catlina.out 构建镜像 1docker build -t diytomcat . 启动镜像 访问测试 发布项目（由于做了卷挂载，我们直接在本地编写项目就可以发布了） 发布自己的镜像 Dockerhub 注册账号 提交镜像 12345678910111213141516171819[root@izbp11tm4pvghonrtfzq17z logs]# docker login --helpUsage: docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username[root@izbp11tm4pvghonrtfzq17z logs]# docker login -u millacheungPassword: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded 登录完毕后可以提交镜像，docker push 123456789101112131415161718192021222324252627# push 镜像到服务[root@izbp11tm4pvghonrtfzq17z logs]# docker push diytomcatUsing default tag: latestThe push refers to repository [docker.io/library/diytomcat]2253e480aa92: Preparing e2fb1874d47d: Preparing b87b1ae0e357: Preparing 2694d93fe799: Preparing 2653d992f4ef: Preparing denied: requested access to the resource is denied# push 镜像出现的问题[root@izbp11tm4pvghonrtfzq17z logs]# docker push milla/diytomcat:latestThe push refers to repository [docker.io/milla/diytomcat]An image does not exist locally with the tag: milla/diytomcat# 解决方法，增加 tag[root@izbp11tm4pvghonrtfzq17z logs]# docker tag diytomcat millacheung/diytomcat# docker push[root@izbp11tm4pvghonrtfzq17z logs]# docker push millacheung/diytomcat:latestThe push refers to repository [docker.io/millacheung/diytomcat]2253e480aa92: Pushing [====================================&gt; ] 41.91MB/57.96MBe2fb1874d47d: Pushed b87b1ae0e357: Pushing [===&gt; ] 21.14MB/311.3MB2694d93fe799: Pushed 2653d992f4ef: Pushing [===========&gt; ] 49.6MB/209.3MB 提交时按照镜像的层级来进行提交 阿里云镜像服务 登录阿里云 找到容器镜像服务 创建命名空间 创建容器镜像 参考官方文档 小结 Docker 网络理解 Dokcer0 测试 12345678910111213141516[root@izbp11tm4pvghonrtfzq17z home]# ip addr# 本机回环地址1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever# 阿里云内网地址2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:0f:39:1e brd ff:ff:ff:ff:ff:ff inet 172.19.36.148/18 brd 172.19.63.255 scope global dynamic eth0 valid_lft 313417324sec preferred_lft 313417324sec# docker0 地址3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN link/ether 02:42:ce:1b:39:e2 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 三个网络 123456789101112131415161718192021# 问题：docker是如何处理容器网路访问的？[root@izbp11tm4pvghonrtfzq17z home]# docker run -d -P --name tomcat01 tomcat# 查看容器的内部网络地址 ip addrroot@d2c76440e08c:/usr/local/tomcat# docker exec -it tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever96: eth0@if97: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever[root@izbp11tm4pvghonrtfzq17z home]# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.078 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.055 ms# linux 可以 ping 通 docker 容器内部 原理 我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装docker，就会有一个网卡docker0桥接模式，使用的技术是evth-pair技术 123456789101112131415[root@izbp11tm4pvghonrtfzq17z ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:0f:39:1e brd ff:ff:ff:ff:ff:ff inet 172.19.36.148/18 brd 172.19.63.255 scope global dynamic eth0 valid_lft 313341488sec preferred_lft 313341488sec3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ce:1b:39:e2 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever97: veth4b9a8e7@if96: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP link/ether 22:18:1b:f3:c5:78 brd ff:ff:ff:ff:ff:ff link-netnsid 0 再启动一个容器测试 1234567891011121314151617[root@izbp11tm4pvghonrtfzq17z ~]# ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:16:3e:0f:39:1e brd ff:ff:ff:ff:ff:ff inet 172.19.36.148/18 brd 172.19.63.255 scope global dynamic eth0 valid_lft 313341314sec preferred_lft 313341314sec3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ce:1b:39:e2 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever97: veth4b9a8e7@if96: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP link/ether 22:18:1b:f3:c5:78 brd ff:ff:ff:ff:ff:ff link-netnsid 099: vethec40790@if98: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP link/ether c2:ab:cd:48:15:84 brd ff:ff:ff:ff:ff:ff link-netnsid 1 12# 我们发现这些容器的网卡都是成对出现的# evth-pair 就是一对的虚拟设备接口，它们都是成对出现的，一端连着协议，一端彼此相连 测试tomcat01和tomcat02能否ping通 1234567[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat02 ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.071 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.068 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.069 ms# 结论：容器与容器之间可以ping通 结论：tomcat01 和 tomcat02 是公用的一个路由器，docker0 所有的容器不指定网络的情况下，都是docker0路由的，dokcer会给我们的容器分配一个默认的可用ip 小结 Docker 使用的是 Linux 的桥接，宿主机中的 Docker 容器的网桥 docker0 Docker 中所有的网络接口都是虚拟的。虚拟的转发效率高（内网传递文件） 容器删除，对应的一对网桥就没有了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[root@izbp11tm4pvghonrtfzq17z leehom]# docker network inspect e7a006437936[ &#123; &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;e7a0064379362e134aced403c3e2bc73db70bd98a2830787f45a158368323502&quot;, &quot;Created&quot;: &quot;2021-04-01T16:51:27.856717249+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;6e5ee47e9ccc386af6dcdffdaad06718a148eebba917e8eb2292c843e40965da&quot;: &#123; &quot;Name&quot;: &quot;tomcat01&quot;, &quot;EndpointID&quot;: &quot;0cf49233384d24ffbdd296e9e7b2d2ca02de157310e008ab485ea4aeee470239&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;7c70125cd4cdab95ce51ff55259dda98e83caa0d49f5e6579d0bce7200d47236&quot;: &#123; &quot;Name&quot;: &quot;tomcat02&quot;, &quot;EndpointID&quot;: &quot;2e8f62ed15e6aacc0e3cff7c712712bad0ae29eec389727f86c3416e47be3ba9&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;e35a92622d4eac78b76441922b9b62d6b80aa437f71d503c1c8faa43b07226bd&quot;: &#123; &quot;Name&quot;: &quot;tomcat03&quot;, &quot;EndpointID&quot;: &quot;59dd49520fd816504d7afc71c5cd4eb10b82c6d1e7e5b11eb91fd49f3273dc54&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:04&quot;, &quot;IPv4Address&quot;: &quot;172.17.0.4/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123; &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; &#125;, &quot;Labels&quot;: &#123;&#125; &#125;] –link 思考一个问题，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以处理这个问题，可以用名字来访问容器？ 123456789101112131415# 如何解决[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Name or service not known# 通过 --link 解决网络连通问题[root@izbp11tm4pvghonrtfzq17z leehom]# docker run -d -P --name tomcat03 --link tomcat02 tomcate35a92622d4eac78b76441922b9b62d6b80aa437f71d503c1c8faa43b07226bd[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat03 ping tomcat02PING tomcat02 (172.17.0.3) 56(84) bytes of data.64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.095 ms64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.066 ms# tomcat02 ping tomcat03 不能 ping 通[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat02 ping tomcat03ping: tomcat03: Name or service not known 12345678910# 查看 hosts 配置[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat03 cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.17.0.3 tomcat02 7c70125cd4cd172.17.0.4 e35a92622d4e 本质：–link 就是在 hosts 配置中增加了 172.17.0.3 tomcat02 7c70125cd4cd 不建议使用 –link，可自定义网络 自定义网络 查看所有的docker网络 12345[root@izbp11tm4pvghonrtfzq17z leehom]# docker network lsNETWORK ID NAME DRIVER SCOPEe7a006437936 bridge bridge locald6e06ccae567 host host local276f39254100 none null local 网络模式 bridge：桥接 docker none：不配置网络 host：和宿主机共享网络 container：容器内网络连通（用的少） 测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 默认启动方式[root@izbp11tm4pvghonrtfzq17z leehom]# docker run -d -P --name tomcat01 --net brige tomcat# docker0特点：默认，域名不能访问，--link可以打通连接# 自定义网络# --driver bridge# --submet 192.168.0.0/16# --gateway 192.168.0.1 [root@izbp11tm4pvghonrtfzq17z leehom]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 myneta8130b5778b5246ae08f2573d1f55874b07fe0b4e974546e51c0a67ff2264284[root@izbp11tm4pvghonrtfzq17z leehom]# docker network lsNETWORK ID NAME DRIVER SCOPEe7a006437936 bridge bridge locald6e06ccae567 host host locala8130b5778b5 mynet bridge local276f39254100 none null local[root@izbp11tm4pvghonrtfzq17z leehom]# docker network inspect mynet [ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;a8130b5778b5246ae08f2573d1f55874b07fe0b4e974546e51c0a67ff2264284&quot;, &quot;Created&quot;: &quot;2021-04-07T21:52:40.22602269+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123;&#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;][root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat-net-01 ping 192.168.0.3PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.091 ms64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.066 ms[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat-net-01 ping tomcat-net-02PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.045 ms64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.066 ms 自定义的网络 docker 已经为我们维护好了对应的关系，推荐使用自定义网络 好处： redis-不同的集群使用不同的网络，保证集群的安全和健康 mysql-不同的集群使用不同的网络，保证集群的安全和健康 网络连通12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 测试打通 tomcat01 - mynet[root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat01 ping tomcat-net-01ping: tomcat-net-01: Name or service not known# 连通之后，就是将 tomcat01 放到了mynet 网络下# 一个容器，两个 ip 地址[root@izbp11tm4pvghonrtfzq17z leehom]# docker network inspect mynet[ &#123; &quot;Name&quot;: &quot;mynet&quot;, &quot;Id&quot;: &quot;a8130b5778b5246ae08f2573d1f55874b07fe0b4e974546e51c0a67ff2264284&quot;, &quot;Created&quot;: &quot;2021-04-07T21:52:40.22602269+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: &#123; &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Config&quot;: [ &#123; &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;, &quot;Gateway&quot;: &quot;192.168.0.1&quot; &#125; ] &#125;, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: &#123; &quot;Network&quot;: &quot;&quot; &#125;, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: &#123; &quot;47c169e5b0ff22f10f9b795327dd14a2b25884d47795d3c8be2fc199eb1ec678&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-02&quot;, &quot;EndpointID&quot;: &quot;31b0d7cf175b6273550c1097da9aa940aa393f36b47a2cccc5f92f4bc4e1a027&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;73c799dc3dbd960990cd7f4af587e9b3ab963acc5cf8c327e975406f4ceb3f44&quot;: &#123; &quot;Name&quot;: &quot;tomcat-net-01&quot;, &quot;EndpointID&quot;: &quot;2459102c7efe9b28ce275501698f61423c97e412579747e1b45f95fafbd1c839&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125;, &quot;d5c8c62a6a5647641f4e5d9e976485a425aae8e14f736ab9547bec5b0a43b6c8&quot;: &#123; &quot;Name&quot;: &quot;tomcat01&quot;, &quot;EndpointID&quot;: &quot;343ef02285daa9192babaf7cabc95aa3e49a4c99a1b880603907aca90cead7a7&quot;, &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:04&quot;, &quot;IPv4Address&quot;: &quot;192.168.0.4/16&quot;, &quot;IPv6Address&quot;: &quot;&quot; &#125; &#125;, &quot;Options&quot;: &#123;&#125;, &quot;Labels&quot;: &#123;&#125; &#125;][root@izbp11tm4pvghonrtfzq17z leehom]# docker exec -it tomcat01 ping tomcat-net-01PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data.64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.069 ms64 bytes from tomcat-net-01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.068 ms 实战：部署 Redis 集群123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 创建网卡docker network create redis --subnet 172.38.0.0/16# 通过脚本创建六个 redis 配置for port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;&gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdonedocker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \\-v /mydata/redis/node-$&#123;port&#125;/data:/data \\-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \\docker run -p 6376:6379 -p 16376:16379 --name redis-6 \\-v /mydata/redis/node-6/data:/data \\-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf; \\# 创建集群 /data # redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 172.38.0.15:6379 to 172.38.0.11:6379Adding replica 172.38.0.16:6379 to 172.38.0.12:6379Adding replica 172.38.0.14:6379 to 172.38.0.13:6379M: 2210d0aa0077512aa4622b6a7e9af8a8f10d57e5 172.38.0.11:6379 slots:[0-5460] (5461 slots) masterM: 1fd400bd8d53196b265c2c8f8d247af5e203362f 172.38.0.12:6379 slots:[5461-10922] (5462 slots) masterM: 5a1efcda61002f7fcf8bf424bb36dddf9049a513 172.38.0.13:6379 slots:[10923-16383] (5461 slots) masterS: cbb471c018d4c62c584a40cbdb340fd651d925b5 172.38.0.14:6379 replicates 5a1efcda61002f7fcf8bf424bb36dddf9049a513S: ead20de555e5be622886e944faae3c98894644d2 172.38.0.15:6379 replicates 2210d0aa0077512aa4622b6a7e9af8a8f10d57e5S: 0c03479f4aa128d4d70e1242f4e542eb65782aa7 172.38.0.16:6379 replicates 1fd400bd8d53196b265c2c8f8d247af5e203362fCan I set the above configuration? (type &#x27;yes&#x27; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join...&gt;&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379)M: 2210d0aa0077512aa4622b6a7e9af8a8f10d57e5 172.38.0.11:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s)M: 5a1efcda61002f7fcf8bf424bb36dddf9049a513 172.38.0.13:6379 slots:[10923-16383] (5461 slots) master 1 additional replica(s)S: 0c03479f4aa128d4d70e1242f4e542eb65782aa7 172.38.0.16:6379 slots: (0 slots) slave replicates 1fd400bd8d53196b265c2c8f8d247af5e203362fM: 1fd400bd8d53196b265c2c8f8d247af5e203362f 172.38.0.12:6379 slots:[5461-10922] (5462 slots) master 1 additional replica(s)S: ead20de555e5be622886e944faae3c98894644d2 172.38.0.15:6379 slots: (0 slots) slave replicates 2210d0aa0077512aa4622b6a7e9af8a8f10d57e5S: cbb471c018d4c62c584a40cbdb340fd651d925b5 172.38.0.14:6379 slots: (0 slots) slave replicates 5a1efcda61002f7fcf8bf424bb36dddf9049a513[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 搭建集群完成 12345678910111213141516171819202122232425262728293031323334353637383940414243/data # redis-cli -c127.0.0.1:6379&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:185cluster_stats_messages_pong_sent:184cluster_stats_messages_sent:369cluster_stats_messages_ping_received:179cluster_stats_messages_pong_received:185cluster_stats_messages_meet_received:5cluster_stats_messages_received:369127.0.0.1:6379&gt; cluster nodes5a1efcda61002f7fcf8bf424bb36dddf9049a513 172.38.0.13:6379@16379 master - 0 1617807387578 3 connected 10923-163830c03479f4aa128d4d70e1242f4e542eb65782aa7 172.38.0.16:6379@16379 slave 1fd400bd8d53196b265c2c8f8d247af5e203362f 0 1617807386576 6 connected1fd400bd8d53196b265c2c8f8d247af5e203362f 172.38.0.12:6379@16379 master - 0 1617807387979 2 connected 5461-10922ead20de555e5be622886e944faae3c98894644d2 172.38.0.15:6379@16379 slave 2210d0aa0077512aa4622b6a7e9af8a8f10d57e5 0 1617807387000 5 connected2210d0aa0077512aa4622b6a7e9af8a8f10d57e5 172.38.0.11:6379@16379 myself,master - 0 1617807385000 1 connected 0-5460cbb471c018d4c62c584a40cbdb340fd651d925b5 172.38.0.14:6379@16379 slave 5a1efcda61002f7fcf8bf424bb36dddf9049a513 0 1617807386977 4 connected127.0.0.1:6379&gt; set a b-&gt; Redirected to slot [15495] located at 172.38.0.13:6379OK172.38.0.13:6379&gt; get a^C/data # get a/bin/sh: get: not found/data # redis-cli -c127.0.0.1:6379&gt; get a-&gt; Redirected to slot [15495] located at 172.38.0.14:6379&quot;b&quot;172.38.0.14:6379&gt; cluster nodescbb471c018d4c62c584a40cbdb340fd651d925b5 172.38.0.14:6379@16379 myself,master - 0 1617807599000 7 connected 10923-16383ead20de555e5be622886e944faae3c98894644d2 172.38.0.15:6379@16379 slave 2210d0aa0077512aa4622b6a7e9af8a8f10d57e5 0 1617807600740 5 connected2210d0aa0077512aa4622b6a7e9af8a8f10d57e5 172.38.0.11:6379@16379 master - 0 1617807600000 1 connected 0-54600c03479f4aa128d4d70e1242f4e542eb65782aa7 172.38.0.16:6379@16379 slave 1fd400bd8d53196b265c2c8f8d247af5e203362f 0 1617807599737 6 connected1fd400bd8d53196b265c2c8f8d247af5e203362f 172.38.0.12:6379@16379 master - 0 1617807599000 2 connected 5461-109225a1efcda61002f7fcf8bf424bb36dddf9049a513 172.38.0.13:6379@16379 master,fail - 1617807501517 1617807500000 3 connected SpringBoot 微服务打包 Docker 镜像Docker ComposeDocker SwarmCI/CD 之 Jenkins","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.milla.club/categories/Docker/"}],"tags":[{"name":"Dcoker","slug":"Dcoker","permalink":"http://www.milla.club/tags/Dcoker/"},{"name":"Linux","slug":"Linux","permalink":"http://www.milla.club/tags/Linux/"}]},{"title":"切换镜像站点","slug":"切换镜像站点","date":"2021-04-05T09:19:34.000Z","updated":"2021-04-05T09:22:59.129Z","comments":true,"path":"2021/04/05/切换镜像站点/","link":"","permalink":"http://www.milla.club/2021/04/05/%E5%88%87%E6%8D%A2%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9/","excerpt":"","text":"npm 切换镜像站点方法一：1. 更改npm配置文件：1$ npm config set registry URL URL 即为需要设置的镜像站点地址，如淘宝镜像: http://registry.npm.taobao.org 方法二： 安装nrm 管理 1. 全局安装 nrm1$ npm install -g nrm 2. 查看镜像地址列表1$ nrm ls 如果报错信息为：throw new ERR_INVALID_ARG_TYPE(name, ‘string’, value);处理方法为：链接 3. 切换镜像地址1$ nrm use company 4. 自定义添加镜像地址：1$ nrm add &lt;registry&gt; &lt;url&gt; 5. 删除镜像地址1$ nrm del company 6. 测试镜像地址响应速度6.1. 测试单个源：1$ nrm test npm 6.2. 测试全部源：1$ nrm test 7. 访问源主页1$ nrm home taobao 此命令会在浏览器中打开淘宝源的主页：https://npm.taobao.org/注：如果要查看自己添加的源的主页，那么在添加源的时候就要把主页带上： 1$ nrm add company http://npm.company.com/ http://npm.company.com/ 如果添加源的时候没有写 home 信息，那么 nrm home 命令不会有效果。 参考页面链接","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.milla.club/categories/JavaScript/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://www.milla.club/tags/Node/"},{"name":"npm","slug":"npm","permalink":"http://www.milla.club/tags/npm/"}]},{"title":"去除inline-block元素间间距的若干方法","slug":"去除inline-block元素间间距的若干方法","date":"2020-04-24T09:11:54.000Z","updated":"2020-04-24T09:11:54.564Z","comments":true,"path":"2020/04/24/去除inline-block元素间间距的若干方法/","link":"","permalink":"http://www.milla.club/2020/04/24/%E5%8E%BB%E9%99%A4inline-block%E5%85%83%E7%B4%A0%E9%97%B4%E9%97%B4%E8%B7%9D%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%96%B9%E6%B3%95/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CSS实现单行和多行文本溢出，省略号显示","slug":"CSS实现单行和多行文本溢出，省略号显示","date":"2020-04-23T05:03:11.000Z","updated":"2020-04-23T05:10:03.516Z","comments":true,"path":"2020/04/23/CSS实现单行和多行文本溢出，省略号显示/","link":"","permalink":"http://www.milla.club/2020/04/23/CSS%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%E5%92%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%EF%BC%8C%E7%9C%81%E7%95%A5%E5%8F%B7%E6%98%BE%E7%A4%BA/","excerpt":"1. 单行文本溢出，省略号显示实现代码： 123overflow: hidden;text-overflow:ellipsis;white-space: nowrap;","text":"1. 单行文本溢出，省略号显示实现代码： 123overflow: hidden;text-overflow:ellipsis;white-space: nowrap; 示例代码： 12345678910111213141516&lt;head&gt; ... &lt;style&gt; div &#123; width: 150px; border: 1px solid #ddd; overflow: hidden; text-overflow:ellipsis; white-space: nowrap; &#125; &lt;/style&gt;&lt;/head&gt;&lt;div&gt; 单行文本溢出，省略号显示&lt;/div&gt;&lt;/body&gt; 效果图： 2. 多行文本溢出，省略号显示 方式1： 实现代码： 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 2;overflow: hidden; 示例代码： 123456789101112131415161718&lt;head&gt; ... &lt;style&gt; div &#123; width: 150px; height: 44px; border: 1px solid #ddd; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;div&gt; 多行文本溢出，省略号显示；多行文本溢出，省略号显示&lt;/div&gt;&lt;/body&gt; 效果图： 适用范围： 因其使用了 WebKit 的 CSS 扩展属性，该方法适用于 WebKit 浏览器及移动端 注释： -webkit-line-clamp 用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的 WebKit 属性。常见结合属性： display: -webkit-box 必须结合的属性，将对象作为弹性伸缩盒子模型显示 。 -webkit-box-orient 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式 。 方式2： 实现代码： 123456789101112131415161718div &#123; position: relative; line-height: 20px; max-height: 40px; overflow: hidden;&#125;div::after&#123; content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px; padding-right: 5px; background: -webkit-linear-gradient(left, transparent, #fff 65%); background: -o-linear-gradient(right, transparent, #fff 65%); background: -moz-linear-gradient(right, transparent, #fff 65%); background: linear-gradient(to right, transparent, #fff 65%);&#125; 示例代码： 123456789101112131415161718192021222324252627282930&lt;head&gt; ... &lt;style&gt; div &#123; position: relative; width: 150px; border: 1px solid #ddd; line-height: 20px; max-height: 40px; overflow: hidden; &#125; div::after&#123; content: &quot;...&quot;; position: absolute; bottom: 0; right: 0; padding-left: 40px; padding-right: 5px; background: -webkit-linear-gradient(left, transparent, #fff 65%); background: -o-linear-gradient(right, transparent, #fff 65%); background: -moz-linear-gradient(right, transparent, #fff 65%); background: linear-gradient(to right, transparent, #fff 65%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 多行文本溢出，省略号显示；多行文本溢出，省略号显示&lt;/div&gt;&lt;/body&gt; 效果图： 适用范围： 适用范围广，可结合 js 进行优化 注释： 将 height 设置为 line-height 的整数倍，防止超出的文字露出。 给 div::after 添加渐变背景可避免文字只显示一半。 由于 IE6-7 不显示 content 内容，所以要添加标签兼容 ie6-7（如：&lt;span&gt;…&lt;span/&gt;）；兼容 IE8 需要将 ::after 替换成 :after 。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.milla.club/tags/CSS/"}]},{"title":"清除浮动若干方法","slug":"清除浮动若干方法","date":"2020-04-23T01:55:32.000Z","updated":"2020-04-23T02:35:38.718Z","comments":true,"path":"2020/04/23/清除浮动若干方法/","link":"","permalink":"http://www.milla.club/2020/04/23/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E8%8B%A5%E5%B9%B2%E6%96%B9%E6%B3%95/","excerpt":"1. 为什么清除浮动由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占位置，最后父盒子高度为 0 时，就会影响下面的标准流盒子 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响","text":"1. 为什么清除浮动由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占位置，最后父盒子高度为 0 时，就会影响下面的标准流盒子 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 2. 清除浮动本质 清除浮动的本质时清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 语法： 123选择器 &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 实际工作中，只用 clear: both; 清除浮动的策略：闭合浮动（只让浮动在父盒子内部影响，不影响父盒子外面的其它盒子） 3. 清除浮动方法 额外标签法 也称为隔墙法，是 W3C 推荐的做法 父级添加 overflow 属性 父级添加 after 伪元素 父亲添加双伪元素 4. 清除浮动——额外标签法额外标签法也称为隔墙法，是 W3C 推荐的做法 额外标签法会在浮动元素末尾添加一个空的标签。例如 &lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;，或者其它标签（如&lt;br /&gt;等） 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化较差 注意：要求新的空标签必须是块级元素 5. 清除浮动——父级添加 overflow可以给父级添加 overflow 属性，将其属性值设置为 hidden、auto 或 scroll 优点：代码简洁 缺点：无法显示溢出的部分 设置 overflow 为什么能够清除浮动？ 引入一个概念：BFC（Block Formatting Context），块级格式化上下文。BFC 中包括一项 overflow 值不为 visible 的块元素会创建块格式化上下文，设置 overflow 为 hidden 满足了创建一个 BFC 的条件，其实就是创建 BFC，利用 BFC 固有特性清除浮动，具体详情见 MDN 6. 清除浮动——:after 伪元素法:after 方式是额外标签法的升级版。也是给父元素添加 12345678910.clearfix::after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; /* IE6、7专有 */ *zoom: 1;&#125; 优点：没有增加标签，结构更简单 缺点：不能照顾低版本浏览器 代表网站：百度、淘宝、网易等 7. 清除浮动——双伪元素法也是给父元素添加 12345678910.clearfix::before, .clearfix::after &#123; content: &quot;&quot;; display: table;&#125;.clearfix::after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码更简洁 缺点：不能照顾低版本浏览器 代表网站：小米、腾讯等 8. 总结为什么要清除浮动？ 父级没高度 子盒子浮动 影响下面布局 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差 父级 overflow: hidden; 书写简单 无法显示溢出的部分 父级 :after 伪元素 符合结构语义化 由于 IE6/7 不支持 :after，兼容性较差 父级双伪元素 符合结构语义化 由于 IE6/7不支持 :after :before，兼容性较差","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.milla.club/tags/CSS/"}]},{"title":"Sass和Less的区别","slug":"Sass和Less的区别","date":"2020-04-22T08:25:56.000Z","updated":"2020-04-22T08:55:50.204Z","comments":true,"path":"2020/04/22/Sass和Less的区别/","link":"","permalink":"http://www.milla.club/2020/04/22/Sass%E5%92%8CLess%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"1. Sass&amp;Less是什么？Less（Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言 Sass，作为“世界上最成熟、最稳定、最强大的专业级CSS扩展语言”","text":"1. Sass&amp;Less是什么？Less（Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言 Sass，作为“世界上最成熟、最稳定、最强大的专业级CSS扩展语言” 2. 两者异同相同之处: 1、混入(Mixins)——class 中的 class； 2、参数混入——可以传递参数的 class，就像函数一样； 3、嵌套规则——class 中嵌套 class，从而减少重复的代码； 4、运算——CSS 中用上数学； 5、颜色功能——可以编辑颜色； 6、名字空间(namespace)——分组样式，从而可以被调用； 7、作用域——局部修改样式； 8、JavaScript 赋值——在 CSS 中使用 JavaScript 表达式赋值。 不同之处: 类别 Sass Less 安装 Sass 的安装需要安装 Ruby 环境 Less 基于 JavaScript 需要引入 Less.js 来处理代码输出 css 到浏览器，也可以在开发环节使用 Less，然后编译成 css 文件，直接放在项目中 使用 复杂 简单 功能 复杂 简单 处理机制 通过服务端处理 通过客户端处理，解析相比 Sass 稍慢 变量 以 $ 开始 以 @ 开始 文件后缀 .sass 或 .scss .less 1、Less 在 JS 上运行，Sass 在 Ruby 上使用。 Sass 基于 Ruby，需要安装 Ruby。Less 和 Sass 在 Ruby 中构建相似，但它已被移植到 JavaScript 中。为了使用 LESS，我们可以将适用的 JavaScript 文件上载到服务器或通过脱机编译器编译 CSS 表。 2、编写变量的方式不同。 Sass 使用 $，而 Less 使用 @。 3、在 Less 中，仅允许循环数值。 在 Sass 中，我们可以遍历任何类型的数据。但在 Less 中，我们只能使用递归函数循环数值。 4、Sass 有 Compass，Less 有 Preboot Sass 和 Less 有可用于集成 mixins 的扩展（在整个站点中存储和共享 CSS 声明的能力）。 Sass 有适用于 mixins 的 Compass，其中包括所有可用的选项以及未来支持的更新。 Less 有 Preboot.less，Less Mixins，Less Elements，gs 和 Frameless。Less 的软件支持比 Sass 更加分散，导致许多不同的扩展选项可能不会以相同的方式运行。对于项目，我们可能需要所有列出的扩展以获得与 Compass 类似的性能。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.milla.club/tags/CSS/"},{"name":"Less","slug":"Less","permalink":"http://www.milla.club/tags/Less/"},{"name":"Sass","slug":"Sass","permalink":"http://www.milla.club/tags/Sass/"}]},{"title":"JS的短路运算符","slug":"JS的短路运算符","date":"2019-12-13T08:00:52.000Z","updated":"2020-04-21T06:13:58.647Z","comments":true,"path":"2019/12/13/JS的短路运算符/","link":"","permalink":"http://www.milla.club/2019/12/13/JS%E7%9A%84%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"JS的短路运算符在JS函数中我们经常会使用到短路运算符，主要是逻辑与（&amp;&amp;） 和 逻辑或（||）。","text":"JS的短路运算符在JS函数中我们经常会使用到短路运算符，主要是逻辑与（&amp;&amp;） 和 逻辑或（||）。 1. 逻辑与 &amp;&amp; 的运算方式12var a = 3 &amp;&amp; 5;console.log(a); //返回的结果为 5 如果逻辑与运算符左边的值布尔转换后为true，那么返回右边的值（不管右边的值是真还是假）。 12345var a = false &amp;&amp; 5;console.log(a); //返回的结果为 falsevar a = null &amp;&amp; 5;console.log(a); //返回的结果为 null 如果逻辑与运算符左边的值布尔转换后为false，那么返回左边的值，但是当逻辑与的左边为 null/NaN/undefined ，结果就会得到null/NaN/undefined。 2. 逻辑或 || 的运算方式12var a = false || 5;console.log(a); //返回的结果为 5 如果逻辑或运算符左边的值布尔转换后为false，那么返回右边的值（不管右边的值是真还是假）。 12345var a = true || 5;console.log(a); //返回的结果为 truevar a = null || null;console.log(a); //返回的结果为 null 如果逻辑或运算符左边的值布尔转换后为true，那么返回左边的值，如果两个操作数都是是null/NaN/undefined，返回null/NaN/undefined。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.milla.club/tags/JavaScript/"}]},{"title":"对Sort()函数的理解（函数引用带括号与不带括号的区别）","slug":"对Sort-函数的理解（函数引用带括号与不带括号的区别）","date":"2019-10-22T14:58:13.000Z","updated":"2020-04-21T06:20:57.639Z","comments":true,"path":"2019/10/22/对Sort-函数的理解（函数引用带括号与不带括号的区别）/","link":"","permalink":"http://www.milla.club/2019/10/22/%E5%AF%B9Sort-%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8%E5%B8%A6%E6%8B%AC%E5%8F%B7%E4%B8%8E%E4%B8%8D%E5%B8%A6%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89/","excerpt":"1.sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数 2.语法 list.sort(key=None, reverse=False) 3.参数 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 &lt;理解：表述元素的权重，如果函数中指定了key，那么就按照key指定的函数list中的元素进行权值从小到大排序&gt; reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认） 4.返回值 该方法没有返回值，但是会对列表的对象进行排序","text":"1.sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数 2.语法 list.sort(key=None, reverse=False) 3.参数 key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 &lt;理解：表述元素的权重，如果函数中指定了key，那么就按照key指定的函数list中的元素进行权值从小到大排序&gt; reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认） 4.返回值 该方法没有返回值，但是会对列表的对象进行排序 5.实例 12345aList = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Facebook&#x27;] aList.sort()print ( &quot;List : &quot;, aList)# 输出结果：List : [&#x27;Facebook&#x27;, &#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;] 12345678910def length(x): return len(x)aList = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Facebook&#x27;]aList.sort(key=length) # 以下讲解调用函数带括号与不带括号区别# 该函数中，使用了key参数，可知，排序list中的元素使用length函数进行排序，length函数中返回值为元素的长度，故可知使用元素长度对元素进行排序，# 故元素Facebook长度最长，排最后，由于其他参数长度相同，故采用默认排序方式进行排序。print ( &quot;List : &quot;, aList)# 输出结果：List : [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Facebook&#x27;] 上述代码可改写为lambda函数 12345aList = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Facebook&#x27;]aList.sort(key=lambda x:len(x)) print ( &quot;List : &quot;, aList)# 输出结果：List : [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Facebook&#x27;] 12345vowels = [&#x27;e&#x27;, &#x27;a&#x27;, &#x27;u&#x27;, &#x27;o&#x27;, &#x27;i&#x27;]vowels.sort(reverse=True) # 降序排序print ( &#x27;result：&#x27;, vowels )# 输出结果：result： [&#x27;u&#x27;, &#x27;o&#x27;, &#x27;i&#x27;, &#x27;e&#x27;, &#x27;a&#x27;] 6.调用函数带括号及不带括号区别 123456789# 带括号def fun1(): return 1a = fun1()print(a)# 输出结果：1# 输出结果为1，调用函数时带括号，表示该函数的执行结果 123456789# 不带括号def fun2(): return 1b = fun2print(b)# 输出结果：&lt;function fun2 at 0x00000287B5CA4D90&gt;# 第二次的输出结果为fun2的内存，表示不带括号调用为调用该函数","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.milla.club/tags/Python/"}]},{"title":"JS对象操作属性的两种方式","slug":"JS对象操作属性的两种方式","date":"2019-10-20T10:11:14.000Z","updated":"2020-04-21T06:15:20.154Z","comments":true,"path":"2019/10/20/JS对象操作属性的两种方式/","link":"","permalink":"http://www.milla.club/2019/10/20/JS%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"在 JS 对象中，调用属性一般有两种方法——点和中括号的方法。1.使用点方法 12345var obj = &#123; name: &quot;cedric&quot;&#125;console.log(obj.name); // cedric","text":"在 JS 对象中，调用属性一般有两种方法——点和中括号的方法。1.使用点方法 12345var obj = &#123; name: &quot;cedric&quot;&#125;console.log(obj.name); // cedric 2.使用 [ ] 方法 12345var obj = &#123; name: &quot;cedric&quot;&#125;console.log(obj[&quot;name&quot;]); // cedric 点方法是在对象名后面跟上属性名，而中括号方法里的索引存放的与属性名字相同的字符串。 二者区别 点方法后面跟的必须是一个指定的属性名称，而中括号方法里面可以是变量。例如 12345678var obj = &#123; name: &quot;cedric&quot;&#125;var haha = &quot;name&quot;;console.log(obj.haha); // undefinedconsole.log(obj[haha]); // cedric 中括号方法里面的属性名可以是数字，而点方法后面的属性名不可以是数字 当动态为对象添加属性时，必须使用 中括号 []， 不可以用点方法","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.milla.club/tags/JavaScript/"}]},{"title":"CSS","slug":"CSS","date":"2019-06-15T11:35:43.000Z","updated":"2020-04-21T06:13:06.093Z","comments":true,"path":"2019/06/15/CSS/","link":"","permalink":"http://www.milla.club/2019/06/15/CSS/","excerpt":"1. CSS 简介1.1. HTML的局限性HTML 只关注内容的语义。 1.2. CSS-网页的美容师CSS 是层叠样式表（Cascading Style Sheets）的简称 也称为 CSS 样式表 或 级联样式表","text":"1. CSS 简介1.1. HTML的局限性HTML 只关注内容的语义。 1.2. CSS-网页的美容师CSS 是层叠样式表（Cascading Style Sheets）的简称 也称为 CSS 样式表 或 级联样式表 CSS 也是一种 标记语言 CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及 版面的布局和外观显示样式 CSS 让网页更加丰富多彩，布局更加灵活自如。简单理解：CSS 可以美化 HTML，让 HTML 更漂亮，让页面布局更简单。 总结： HTML 主要做结构，显示元素内容 CSS 美化 HTML，布局网页 CSS 最大价值：由 HTML 专注去做结构呈现，样式交给 CSS，即结构（HTML）与样式（CSS）相分离 1.3. CSS 语法规范使用 HTML 时，需要遵从一定的规范，CSS 也是如此。 CSS 规则由两个主要的部分组成：选择器以及一条或多条声明。 选择器用于指定 CSS 样式的 HTML 标签，花括号内是对该对象设x置的具体样式 属性和属性值之间以 ”键值对“ 形式出现 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等 属性和属性值之间用英文 “:” 分开 多个 “键值对” 之间用英文 “;” 进行区分 1.4. CSS 代码风格1.4.1. 样式格式书写 紧凑格式 1h3 &#123; color: red; font-size: 12px; &#125; 展开格式 1234h3 &#123; color: red; font-size: 12px; &#125; 推荐第二种格式，因为更直观 1.4.2. 样式大小写1234h3 &#123; color: red; font-size: 12px; &#125; 1234H3 &#123; COLOR: RED; FONT-SIZE: 12PX; &#125; 推荐全部使用小写字母，特殊情况除外。 1.4.3. 空格规范1234h3 &#123; color: red; font-size: 12px; &#125; 属性值前面，冒号后面，保留一个空格 选择器（标签）和大括号中间保留空格 2. CSS 基础选择器2.1. CSS 选择器的作用选择器（选择符）就是根据不同需求把不同的标签选出来，这就是选择器的作用，简单的说，就是选择标签。 2.2. 选择器分类选择器分为 基础选择器 和 复合选择器 两个大类。 基础选择器由 单个选择器组成 基础选择器又包括：标签选择器、类选择器、id选择器 和 通配符选择器 2.3. 标签选择器标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。 语法： 123456标签名 &#123; 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; ...&#125; 作用： 标签选择器可以把某一类标签全部选择出来，比如所有的 &lt;div&gt; 标签和所有的 &lt;span&gt; 标签 优点： 能快速的为页面中同类型的标签统一设置样式 缺点： 不能设置差异化样式，只能选择全部的当前标签。 2.4. 类选择器如果想要差异化的选择不同的标签，单独选一个或者某几个标签，可以使用类选择器 类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个点 “.” 号显示。 语法： 1234.类名 &#123; 属性1: 属性值1; ...&#125; 例如，将所有拥有 red 类的 HTML 元素设置为红色。 123.red &#123; color: red;&#125; 结构需要用 class 属性来调用 class 类的样式 1&lt;div class=&quot;red&quot;&gt;变红色&lt;/div&gt; 注意： 类选择器使用 “.” （英文点号）进行表示，后面紧跟类名（自定义） 可以理解为给标签起了名字 长名称或词组可以使用中横线来为选择器命名 不要使用纯数字、中文等命名，尽量使用英文字母来表示 命名要有意义，尽量使别人一眼就知道这个类名的目的 命名规范：见附件（Web前端开发规范手册.pdf） 2.5. 类选择器-多类名给一个标签指定多个类名，从而达到更多的选择目的。这些类名都可以选出这个标签。简单理解就是一个标签有多个名字。 2.5.1. 多类名使用方式1&lt;div class=&quot;red font20&quot;&gt;亚瑟&lt;/div&gt; 在标签 class 属性中写多个类名 多个类名中间必须用空格分开 这个标签就可以分别具有这些类名的样式 2.5.2. 使用场景 可以把一些标签元素相同的样式（共同的部分）放到一个类里面 这些标签都可以调用这个公共的类，然后再调用自己独有的类 节省 CSS 代码，统一修改也方便 123&lt;div class=&quot;box green&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box red&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box green&quot;&gt;&lt;/div&gt; 各个类名中间用空格隔开 简单理解：就是给某个标签添加了多个类 这个标签就可以分别具有这些类名的样式 节省 CSS 代码，统一修改也方便 多类名选择器在后期布局比较复杂的情况下，使用较多 2.6. id 选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式 HTML 元素以 id 属性来设置 id 选择器，CSS中 id 选择器以 “#” 来定义 语法： 1234#id名 &#123; 属性1: 属性值1; ...&#125; 例如，将拥有 id 为 red 的 HTML 元素设置为红色。 123#red &#123; color: red;&#125; id 选择器和类选择器的区别 类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用 id 选择器好比人的身份证，全中国唯一，不重复 id 选择器和类选择器最大的区别在于使用次数 类选择器在修改样式中用的最多，id 选择器一般用于页面上唯一性的元素，经常和 JS 搭配使用 2.7. 通配符选择器在 CSS 中，通配符选择器使用 “*” 定义，它表示选取页面中的所有元素（标签）。 语法： 1234* &#123; 属性1: 属性值1; ...&#125; 通配符选择器不需要调用，自动给所有元素添加样式 特殊情况下使用，清除所有元素标签的内外边距 1234* &#123; margin: 0; padding: 0;&#125; 2.8. 基础选择器总结 基础选择器 作用 特点 使用情况 用法 标签选择器 可以选出所有相同的标签，比如 p 不能差异化选择 较多 p &#123; color: red; &#125; 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav &#123; color: red; &#125; id 选择器 一次只能选择1个标签 ID 属性只能在每个 HTML 文档中出现一次 一般和 JS 搭配 #nav &#123; color: red; &#125; 通配符选择器 选择所有的标签 选择的太多，有部分不需要 特殊情况使用 * &#123; color: red; &#125; 每个基础选择器都有使用场景，都需掌握 如果是修改样式，类选择器最常用 3. CSS 字体属性CSS Fonts（字体）属性用于定义字体系列、大小、粗细和文字样式（如斜体）。 3.1. 字体系列CSS 使用 font-family 属性定义文本的字体系列。 12p &#123; font-family: &quot;微软雅黑&quot;; &#125;div &#123; font-family: Arial, &quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;; &#125; 各种字体之间必须使用英文状态下的逗号隔开 一般情况下，如果有空格隔开的多个单词组成的字体，加引号 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示 最常见的几个字体：body &#123; font-family: &quot;Microsoft YaHei&quot;, tahoma, arial, &quot;Hiragino Sans GB&quot;; &#125; 3.2. 字体大小CSS 使用 font-size 属性定义字体大小 123p &#123; font-size: 20px;&#125; px（像素）大小是网页中最常用的单位 谷歌浏览器默认的文字大小为 16px 不同浏览器可能默认显示的字号大小不一致，我们尽可能的给一个明确值大小，不要默认大小 可以给 body 指定整个页面文字的大小 3.3. 字体粗细CSS 使用 font-weight 属性设置文本字体的粗细。 123p &#123; font-weight: 700;&#125; 属性值 描述 normal 默认值（不加粗的） bold 定义加粗（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold，数字后不带单位 实际开发中，数字表示粗细更常用 3.4. 文字样式CSS 使用 font-style 属性设置文本的风格 123p &#123; font-style: italic;&#125; 属性值 描述 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式 注意：平时很少给文字加斜体，反而要给斜体标签（em，i）改为不倾斜字体。 3.5. 字体复合属性字体属性可以把以上文字样式综合来写，这样可以更节约代码 123body &#123; font: font-style font-weight font-size/line-height font-family;&#125; 使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间空格隔开 不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用 3.6. 字体属性总结 属性 表示 注意点 font-size 字号 我们通常用的单位是 px 像素，要跟单位 font-family 字体 实际工作中按照团队约定写字体 font-weight 字体粗细 加粗 700，或 bold；不加粗 400，或 normal，数字不跟单位 font-style 字体样式 倾斜 italic；不倾斜 normal；工作中常用 normal font 字体连写 1.字体连写有顺序，不能随意更换位置 2.字号和字体不能省略 4. CSS 文本属性CSS Text（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。 4.1. 文本颜色color 属性，用于定义文本的颜色 123div &#123; color: red;&#125; 表示 属性值 预定义的颜色值 red，green，blue，pink等 十六进制 #FF0000，#FF6600 RGB代码 rgb(255, 255, 0) 或 rgb(100%, 100%, 0) 开发中最常用十六进制 4.2. 对齐文本text-align 属性用于设置元素内文本内容的水平对齐方式 123div &#123; text-align: center;&#125; 属性值 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 4.3. 装饰文本text-decoration 属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。 123div &#123; text-decoration: underline;&#125; 属性值 描述 none 默认。没有装饰线（最常用） underline 下划线。链接 a 自带下划线（常用） overline 上划线。（几乎不用） line-through 删除线。（不常用） 4.4. 文本缩进text-indent 属性用来指定文本的第一行的缩进，通常是将段落的首行缩进 123div &#123; text-indent: 10px;&#125; 通常设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。 123p &#123; text-indent: 2em;&#125; em 是一个相对单位，就是当前元素（font-size）1个文字的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。 4.5. 行间距line-height 属性用于设置行间的距离（行高）。可以控制文字行与行之间的距离。 123div &#123; line-height: 20px;&#125; 4.6. 文本属性总结 属性 表示 注意点 color 文本颜色 通常用十六进制，简写，例如 #fff text-align 文本对齐 可以设定文字水平的对齐方式 text-indent 文本缩进 通常用于段落首行缩进 2 个字符，text-indent: 2em text-decoration 文本修饰 下划线：underline，取消下划线：none line-height 行高 控制行与行之间的距离 5.CSS 的引入方式5.1. CSS 的三种样式表按照CSS样式书写的位置（或者引入的方式），CSS样式表可分为三大类： 行内样式表（行内式） 内部样式表（嵌入式） 外部样式表（链接式） 5.2. 内部样式表内部样式表（内嵌样式表）是写到 html 页面内部。是将所有的 CSS 代码抽取出来，单独放到一个&lt;style&gt;标签中。 123456&lt;style&gt; div &#123; color: red; font-size: 12px; &#125;&lt;/style&gt; &lt;style&gt; 标签理论上可以放在 HTML 文档的任何地方，但一般会放在文档的 &lt;head&gt; 标签中 通过此种方式，可以方便控制当前整个页面中的元素样式设置 代码结构清晰，但是并没有实现结构与样式完全分离 使用内部样式表设定 CSS，通常也被称为嵌入式引入 5.3. 行内样式表行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式。适合于修改简单样式 1&lt;div style=&quot;color: red; font-size: 20px;&quot;&gt;行内样式&lt;/div&gt; style 其实就是标签的属性 在双引号之间，写法要符合 CSS 规范 可以控制当前的标签设置样式 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有当前元素添加简单样式的时候，可以考虑使用 使用行内样式表设定 CSS，通常也被称为行内式引入 5.4. 外部样式表实际开发都是外部样式表，适合于样式比较多的情况。核心是：样式单独写到 CSS 文件中，之后把 CSS 文件引入到 HTML 页面中使用。 引入外部样式表步骤： 新建一个后缀为 .css 的样式文件，把所有 CSS 代码都放入此文件中 在 HTML 页面中，使用 &lt;link&gt; 标签引入这个文件。 1&lt;link rel=&quot;stylesheet&quot; href=&quot;css文件路径&quot;&gt; 属性 作用 rel 定义当前文挡与被链接文档之间的关系，在这里需要指定为 “stylesheet”，表示被链接的文档是一个样式表文件 href 定义所链接的外部样式表文件的 URL，可以是相对路径，也可以是绝对路径 使用外部样式表设定 CSS，通常也被称为外链式或链接引入式，这种方式是开发中最常用的方式 5.5. CSS引入方式总结 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 结构样式混写 较少 控制一个标签 内部样式表 部分结构与样式相分离 没有彻底分离 较多 控制一个页面 外部样式表 完全实现结构与样式相分离 需要引入 最多 控制多个页面 6. 综合案例综合案例-新闻页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;新闻页面&lt;/title&gt; &lt;style&gt; body &#123; font: 16px/28px &quot;Microsoft YaHei&quot;; &#125; h2 &#123; font-weight: 400; text-align: center; &#125; a &#123; text-decoration: none; &#125; .gray &#123; text-align: center; color: #aaa; font-size: 12px; &#125; .search &#123; color: #666666; width: 170px; &#125; .btn &#123; font-weight: 700; &#125; .img &#123; text-align: center; &#125; p &#123; text-indent: 2em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;天空中同时出现四大天象奇观 摄影师拍下罕见一幕&lt;/h2&gt;&lt;div class=&quot;gray&quot;&gt; &lt;span&gt;2019-12-18 15:00:03 来源：&lt;a href=&quot;#&quot;&gt;中国天气网&lt;/a&gt;&lt;/span&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入查询条件&quot; class=&quot;search&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;搜素&quot; class=&quot;btn&quot;&gt;&lt;/div&gt;&lt;hr&gt;&lt;p&gt;中新网12月18日电 据台湾联合新闻网报道，日本摄影师佐藤圭日前在《现代商业》专栏上，贴出一张照片，这张照片在北海道拍摄，捕捉了四个气象奇观同时出现在一片天空的瞬间。&lt;/p&gt;&lt;div class=&quot;img&quot;&gt; &lt;img src=&quot;images/ca1349540923dd540e472eda759559db9d8248ea.jpeg&quot; alt=&quot;&quot;&gt; &lt;div&gt;资料图：日晕景观。中新社记者 贺俊怡 摄&lt;/div&gt;&lt;/div&gt;&lt;p&gt;文中写道，首先是围绕在太阳周边的光圈“日晕”，日晕是由悬浮在大气中的六角形冰晶反射日光后所形成。通常内圈是红光，外圈是紫光。一般来说，会被认为是风暴降临前的征兆。&lt;/p&gt;&lt;p&gt;其次，则是在日晕两旁散发出七彩虹光的“幻日”。幻日常常跟日晕一起出现，是由水平方向的扁平状冰晶形成。因为看起来像是有复数的太阳出现，而被传说为不祥之兆。&lt;/p&gt;&lt;p&gt;从“幻日”外侧往外延伸的水平线，则是“幻日环”。相较于日晕和幻日，幻日环较为少见。完整的幻日环可以圈起整个天空，但一般而言，只能观测到一部分。在中国古代，幻日环常被认为是兵马之乱的前兆。&lt;/p&gt;&lt;p&gt;最后，则是“环天顶弧”，又被称为天空的微笑，看起来就像是倒过来的彩虹。环天顶弧一般伴随着幻日出现，和幻日的成因相同。&lt;/p&gt;&lt;p&gt;佐藤圭表示，自开始摄影以来，他曾经数次遇过这个画面，却总是错过拍摄时机。如今，终于拍摄到这个画面的他，在文中表露了满满的成就感。&lt;/p&gt;&lt;/body&gt; 7. Chrome 调试工具Chrome 浏览器提供了一个非常好用的调试工具，可以用来调试我们的 HTML 结构和 CSS 样式 7.1. 打开调试工具打开 Chrome 浏览器，按下 F12 键或者右击页面空白处→检查 7.2. 使用调试工具 Ctrl + 滚轮 可以放大开发者工具代码大小 左边是 HTML 元素结构，右边是 CSS 样式 右边 CSS 样式可以改动数值（左右箭头或者直接输入）和查看颜色 Ctrl + 0 复原浏览器大小 如果点击元素，发现右侧没有样式引入，既有可能是类名或者样式引入错误 如果有样式，但是样式前面有黄色叹号提示，则是样式属性书写错误 8. Emmet 语法Emmet 语法的前身是 Zen coding，它使用缩写，来提高 html/css 的编写速度，Vscode 内部已经集成了该语法。 8.1. 快速生成 HTML 结构语法 生成标签，直接输入标签名，按 Tab 键即可。div → Tab 键 如果想要生成多个相同标签，加上 * 就可以了。div*3 → Tab 键 如果有父子级关系，可以用 &gt; 。ul&gt;li → Tab 键 如果有兄弟关系的标签，用 +。p+div → Tab 键 如果生成带有类名或 id 名字的。直接写 .demo 或 #demo → Tab 键 如果生成的 div 类名是有顺序的，可以用自增符号 $ 如果想要在生成的标签内部写内容可以用 {} 表示 8.2. 快速生成CSS样式语法CSS 基本采取简写形式即可 比如 w200 按 Tab 可以生成 width: 200px; 比如 lh26 按 Tab 可以生成 line-height: 26px; 8.3. 快速格式化代码webstrom：ctrl + alt + L 9. CSS的复合选择器9.1. 什么是复合选择器在 CSS 中，可以根据选择器的类型把选择器分为基础选择器和复合选择器，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。 复合选择器可以更准确、更高效的选择目标元素（标签） 复合选择器是由两个或多个基础选择器，通过不同的组合方式组合而成的 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等 9.2. 后代选择器后代选择器又称为包含选择器，可以选择父元素里面的子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代 语法： 1元素1 元素2 &#123; 样式声明 &#125; 上述语法表示选择 元素1 里面的所有 元素2（后代元素） 例如： 1ul li &#123; 样式声明 &#125; /*选择ul里面的所有li标签元素*/ 元素1 和 元素2 中间用 空格 隔开 元素1 是父级，元素2 是子级，最终选择的是 元素2 元素2 可以是儿子，也可以是孙子等，只要是 元素1 的后代即可 元素1 和 元素2 可以是任意基础选择器 9.3. 子选择器子元素选择器（子选择器）只能选择作为某元素的最近一级子元素。简单理解就是选亲儿子元素 语法： 1元素1&gt;元素2 &#123; 样式声明 &#125; 上述语法表示选择 元素1 里面的所有直接后代（子元素）元素2 例如： 1div&gt;p &#123; 样式声明 &#125; /*选择div里面所有最近一级p标签元素*/ 元素1 和 元素2 中间用 大于号 隔开 元素1 是父级，元素2 是子级，最终选择的是 元素2 元素2 必须是亲儿子，其孙子、重孙之类都不归它管 9.4. 并集选择器并集选择器可以选择多组标签，同时为它们定义相同的样式。通常用于集体声明。 并集选择器是各选择器通过英文逗号连接而成，任何形式的选择器都可以作为并集选择器的一部分 语法： 1元素1, 元素2 &#123; 样式声明 &#125; 上述语法表示选择 元素1 和 元素2 例如： 1234div,p &#123; 样式声明 &#125; /*选择ul和div标签元素*/ 元素1 和 元素2 中间用 逗号 隔开 逗号可以理解为 和 并集选择器通常用于集体声明 9.5. 伪类选择器伪类选择器用于向某些选择器添加特殊的效果，比如给连接添加特殊的效果，或选择第 1 个，第 n 个元素 伪类选择器书写最大的特点是用冒号表示，比如 :hover，:first-child 9.6. 链接伪类选择器1234a:link /*选择所有未被访问的链接*/a:visited /*选择所有已被访问的链接*/a:hover /*选择鼠标指针位于其上的链接*/a:active /*选择活动链接（鼠标按下未弹起的链接）*/ 链接伪类选择器注意事项 为了确保生效，请按照 LVHA 的顺序声明 :link - :visited - :hover - :active 记忆法：love hate 因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式 链接伪类选择器实际开发中的写法 12345678/* a 是标签选择器 所有的链接 */a &#123; color: gray;&#125;/* :hover 是链接伪类选择器 鼠标经过 */a:hover &#123; color: red; /* 鼠标经过的时候，由原来的灰色变成了红色 */&#125; 9.7. :focus 伪类选择器:focus 伪类选择器用于选取获得焦点的表单元素 焦点就是光标，一般情况下 &lt;input&gt; 类表单元素才能获取，因此这个选择器也主要针对表单元素来说 123input:focus &#123; background-color: yellow;&#125; 9.8. 复合选择器总结 选择器 作用 特征 使用情况 隔开符号及用法 后代选择器 用来选择后代元素 可以是子孙后代 较多 符号是空格 子代选择器 选择最近一级元素 只选亲儿子 较少 符号是大于 并集选择器 选择某些相同样式的元素 可以用于集体声明 较多 符号是逗号 链接伪类选择器 选择不同状态的链接 跟链接相关 较多 a &#123;&#125; 和 a:hover :focus选择器 选择获得光标的表单 跟表单相关 较少 input:focus 10. CSS的元素显示模式10.1. 元素显示模式作用：网页的标签非常多，在不同的地方会用到不同类型的标签，了解它们的特点可以更好的布局网页。 HTML 元素一般分为 块元素 和 行内元素 两种类型 10.2. 块元素常见的块元素有 &lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中 &lt;div&gt; 标签是最典型的块元素 块级元素的特点： 独占一行 高度，宽度，内外边距可以控制 宽度默认是容器（父级宽度）的100% 是一个容器及盒子，里面可以放行内或者块级元素 注意： 文字类的元素不能使用块级元素 &lt;p&gt; 标签主要用于存放文字，因此 &lt;p&gt; 里面不能放块级元素，特别是不能放 &lt;div&gt; 同理，&lt;h1&gt;~&lt;h6&gt; 等都是文字类块级标签，里面也不能放其它块级元素 10.3. 行内元素常见的行内元素有 &lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt; 等，其中 &lt;span&gt; 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 行内元素的特点： 相邻行内元素在一行上，一行可以显示多个 宽、高直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能收纳文本或其它行内元素 注意： 链接里面不能再放链接 特殊情况链接 &lt;a&gt; 里面可以放块级元素，但是给 &lt;a&gt; 转换一下块级模式最安全 10.4. 行内块元素在行内元素中有几个特殊的标签，&lt;img /&gt;、&lt;input /&gt;、&lt;td /&gt;，它们同时具有块元素和行内元素的特点。 行内块元素的特点： 和相邻行内元素（行内块）在一行上，但是它们之间会有空白缝隙。一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素的特点） 高度，行高，内外边距可以控制（块级元素特点） 10.5. 元素显示模式总结 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度高度 它本身内容的宽度 容纳文本或其它行内元素 行内块元素 一行放多个行内块元素 可以设置宽度高度 它本身内容的宽度 10.6. 元素显示模式转换特殊情况下，我们需要元素模式的转换，简单理解：一个模式的元素需要另外一种模式的特性 比如想要增加链接 &lt;a&gt; 的触发范围。 转换为块元素：display: block; 转化为行内元素：display: inline; 转换为行内块元素：display:inline-block 10.7. 小工具 snipasteSnipaste 是一个简单但强大的截图工具，也可以让你的截图贴回到屏幕上。 F1 可以截图。同时测量大小，设置箭头，书写文字等 F3 在桌面置顶显示 点击图片，alt 可以取色（按下shift可以切换取色模式） 按下 esc 取消图片显示 10.8. 单行文字垂直居中解决方案1：让文字的行高等于盒子的高度，就可以让文字在当前盒子内垂直居中 解决方案2： 12345div &#123; display: flex; justify-content: center; /*主轴居中*/ align-items: center; /*侧轴居中*/&#125; 10.9. 单行文字垂直居中的原理行高的上空隙和下空隙把文字挤到中间。如果行高小于盒子高度，文字会偏上，如果行高大于盒子高度，文字会偏下 11. CSS 背景通过 CSS 背景属性，可以给页面元素添加背景样式。 11.1. 背景颜色background-color 属性定义了元素的背景颜色 1background-color: 颜色值; 一般情况下元素背景颜色默认是 transparent（透明），可以手动指定背景颜色为透明色 11.2. 背景图片background-image 属性描述了元素的背景图像。实际开发常见于 logo 或者一些装饰性的小图片或者超大的背景图片，优点是非常便于控制位置（精灵图也是一种运用场景） 1background-image: none | url(url) 参数值 作用 none 无背景图（默认的） url 使用绝对或相对地址指定背景图像 11.3. 背景平铺如果需要在 HTML 页面上对背景图像进行平铺，可以使用 background-repeat 属性 1background-repeat: repeat | no-repeat | repeat-x | repeat-y 参数值 作用 repeat 背景图像在纵向和横向上平铺（默认的） no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向上平铺 11.4. 背景图片位置利用 background-position 属性改变图片在背景中的位置 1background-position: x y; 参数代表的意思是：x 坐标和 y 坐标。可以使用 方位名词 或者 精确单位 参数值 说明 length 百分数 | 由浮点数字和单位标识符组成的长度值 position top | center |bottom | left | center | right 方位名词 参数是方位名词 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 参数是精确单位 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是y坐标 如果只指定一个值，那该数值一定是x坐标，另一个默认垂直居中 参数是混合单位 如果指定的两个值是精确单位和方位名词混合使用，则第一个是 x 坐标，第二个是 y 坐标 11.5. 背景图像固定（背景附着）background-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动 background-attachment 后期可以制作视差滚动效果 1background-attachment: scroll | fixed 参数 作用 scroll 背景图像是随对象内容滚动（默认） fixed 背景图像固定 11.6. 背景复合写法为了简化背景属性的代码，可以将这些属性合并简写在同一个属性 background 中，从而节约代码量 当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为： background：背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置； 1background: transparent url(image.jpg) repeat-x fixed top; 这是实际开发中，提倡的写法。 11.7. 背景色半透明CSS3 提供了背景颜色半透明的效果。 1background: rgba(0, 0, 0, .3); 最后一个参数时 alpha 透明度，取值范围 0~1 之间 习惯把 0.3 的 0 省略掉，写为 background: rgba(0, 0, 0, .3); 注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响 CSS3新增属性，IE9+ 11.8. 背景总结 属性 作用 值 background-color 背景颜色 预定义的颜色值/十六进制/RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat | no-repeat |repeat-x | repeat-y background-position 背景位置 length |position 分别是 x 和 y 坐标 background-attachment 背景附着 scroll（背景滚动）/fixed（背景固定） 背景简写 书写简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 背景色透明度 背景颜色透明度 background: rgba(0, 0, 0, .3); 背景图片：实际开发中常见于 logo 或者一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置（精灵图也是一种运用场景） 12.CSS的三大特性CSS有三个非常重要的特征：层叠性、继承性、优先级。 12.1. 层叠性相同选择器给设置同样的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题 层叠性原则： 样式冲突，遵循的原则就是就近原则，哪个样式里结构近，就执行哪个样式 样式不冲突，不会重叠 12.2. 继承性CSS 中的继承：子标签会继承父标签的某些样式，如文本颜色和字号。简单的理解就是：子承父业 恰当的使用继承可以简化代码，降低 CSS 样式的复杂性 子元素可以继承父元素的样式（text-，font-，line-这些元素开头的属性可以继承，以及color属性） 行高的继承 123body &#123; font: 12px/1.5 &quot;Microsoft YaHei&quot;;&#125; 行高可以跟单位，也可以不跟单位 如果子元素没有设置行高，则会继承父元素的行高1.5 此时子元素的行高是：当前子元素的文字大小*1.5 body 行高1.5，这样写法最大优点是里面的子元素可以根据自己文字大小自动调整行高 12.3. 优先级当同一个元素指定多个选择器，就会有优先级的产生。 选择器相同，则执行层叠性 选择器不同，则根据选择器权重执行 选择器权重如下表 选择器 选择器权重 继承 或者 * 0, 0, 0, 0 元素选择器 0, 0, 0, 1 类选择器，伪类选择器 0, 0, 1, 0 ID选择器 0, 1, 0, 0 行内样式 style=”” 1, 0, 0, 0 !important 重要的 ∞无穷大 优先级注意点： 权重是由 4 组数字组成，但是不会有进位 可以理解为类选择器永远大于元素选择器，id 选择器永远大于类选择器，以此类推 等级判断从左向右，如果某一位数值相同，则判断下一位数值 继承的权重是 0，如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重 div ul li (0, 0, 0, 3) .nav ul li (0, 0, 1, 2) a:hover (0, 0, 1, 1) .nav a (0, 0, 1, 1) 13. 盒子模型13.1. 看透网页布局的本质网页布局的过程 先准备好相关的网页元素，网页元素基本上都是 Box 利用 CSS 设置好盒子样式，然后摆放到相应位置 往盒子里面装内容 网页布局的核心本质：就是利用 CSS 摆盒子 13.2. 盒子模型（Box Model）组成盒子模型：就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距和实际内容。 13.3. 边框（border）border 可以设置元素的边框。边框由三部分组成：边框宽度（粗细）、边框样式、边框颜色 语法： 1border: border-width || border-style || bordr-color 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 bordr-color 边框颜色 CSS 边框允许你指定一个元素边框的样式和颜色 边框简写： 1border: 1px solid red; 没有顺序 边框分开写法： 1border-top: 1px solid red; 13.4. 表格的细线边框border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。 1border-collapse: collapse; collapse 单词是合并的意思 border-collapse: collapse; 表示相邻边框合并在一起 13.5. 边框会影响盒子的实际大小边框会额外增加盒子的实际大小。因此有两种方案解决： 测量盒子大小的时候，不量边框 如果测量的时候包含了边框，则通过 width/height 减去边框的宽度 13.6. 内边距（padding）padding 属性用于设置内边距，即边框与内容之间的距离。 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 padding 属性（简写属性）可以有一到四个值。 值的个数 表达意思 padding: 5px; 1个值，代表上下左右都有5像素内边距 padding: 5px 10px; 2个值，代表上下内边距是5像素，左右内边距是10像素 padding: 5px 10px 20px; 3个值，代表上内边距5像素，左右内边距10像素，下内边距20像素 padding: 5px 10px 20px 30px; 4个值，代表上5像素，右10像素，下20像素，左30像素 顺时针方向 当盒子指定 padding 值后，发生了两件事情： 内容和边框有了距离，添加了内边框 padding 影响盒子大小。 如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。 解决方案：如果保证盒子和效果图大小保持一致，则让 width/height 减去多出来的内边距大小即可 如果盒子本身没有指定 width/height 属性，则此时 padding 不会撑开盒子大小（对于 block 元素，padding 值设置大于盒子宽度，一定会影响元素尺寸） 13.7. 外边距margin 属性用于设置外边距，即控制盒子和盒子之间的距离 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin 简写方式与 padding 相同 外边距典型应用 外边距可以让块级盒子水平居中，但是必须满足以下条件： 盒子必须指定了宽度 盒子的左右外边距设置为 auto 1234.header &#123; width: 960px; margin: 0 auto;&#125; 常见的三种写法： margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align: center; 即可。 13.8. 外边距合并使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。 主要有两种情况： 13.8.1. 相邻块元素垂直外边距的合并当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top，则它们之间的垂直距离不是 margin-bottom 与 margin-top 之和。取两个值中的较大者，这种现象被称为相邻元素垂直外边距的合并。 解决方案：尽量只给一个盒子添加 margin 值 13.8.2. 嵌套块元素垂直外边距的塌陷对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。 解决方案： 可以给父元素定义上边框 可以给父元素定义上内边距 可以给父元素添加 overflow: hidden; 还有其他方法，比如浮动、固定、绝对定位的盒子不会有塌陷问题 13.9. 清除内外边距网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。 1234* &#123; padding: 0; /* 清除内边距 */ margin: 0; /* 清除外边距 */&#125; 注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距（不起作用）。但是转换为块级和行内块元素就可以了。 14. PS基本操作因为网页美工大部分效果图都是利用 PS 制作的，所以我们大部分切图工作是在 PS 中完成的。 文件 → 打开：可以打开我们要测量的图片 Ctrl + R：可以打开标尺，或者视图 → 标尺 右击标尺，将单位改为像素 Ctrl + 加号(+) 可以放大视图，Ctrl + 减号(-) 可以缩小视图 按住空格键，鼠标可以变为小手，拖动PS视图 用选区拖动，可以测量大小 Ctrl + D 可以取消选区，或者在旁边空白处点击一下也可以取消选区 15. 总结 布局为什么用不同的盒子？ 标签是有语义的，合理的地方用合理的标签。比如产品标题用 h，大量文字用 p 为什么那么多类名？ 类名就是给盒子起名字，可以更好地找到这个盒子，选取盒子更容易，便于后期维护。 用 margin 还是 padding？ 大部分情况下可以混用，两者各有优缺点，但是根据实际情况，总是有更简单的办法实现。 自己没有思路？ 先模仿，再做自己的风格 16. 圆角边框在 CSS3 中，新增了圆角边框样式，这样我们的盒子就可以变圆角了。 border-radius 属性用于设置元素的外边框圆角。 语法： 1border-radius: length; radius 半径（圆的半径）原理：（椭）圆的边框的交集形成圆角效果 参数值可以为数值或百分比的形式 如果是正方形，想要设置一个圆，把数值改为高度的一半或者宽度的一半即可，或者直接写为 50% 如果是矩形，设置高度的一半就可以做一个两边半圆形的矩形 该属性是一个简写属性，可以跟四个值，分别代表左上角，右上角，右下角，左下角 分开写：border-top-left-radius、border-bottom-left-radius、border-top-right-radius、border-top-right-radius 17. 盒子阴影CSS3 中新增了盒子阴影，我们可以使用 box-shadow 属性为盒子添加阴影。 语法： 1box-shadow: h-shadow v-shadow blur spread color inset; 值 描述 h-shadow 必需。水平阴影的位置。允许负值 v-shadow 必需。垂直阴影的位置。允许负值 blur 可选。模糊距离 spread 可选。阴影的尺寸 color 可选。阴影的颜色 inset 可选。将外部阴影（outset）改为内部阴影 注意： 默认的是外阴影（outset），但是不可以写这个单词，否则导致阴影无效 盒子阴影不占用空间，不会影响其它盒子的排列 18. 文字阴影在 CSS3 中，可以使用 text-shadow 属性将阴影应用于文本。 语法： 1text-shadow: h-shadow v-shadow blur color; 值 描述 h-shadow 必需。水平阴影的位置。允许负值 v-shadow 必需。垂直阴影的位置。允许负值 blur 可选。模糊距离 color 可选。阴影的颜色 19. 浮动19.1. 传统网页布局的三种方式网页布局的本质——用 CSS 来摆放盒子。把盒子摆到相应位置。 CSS 提供了三种传统布局方式： 普通流（标准流） 浮动 定位 19.2. 标准流（普通流/文档流）所谓的标准流：就是标签按照规定好的默认方式排列 块级元素会独占一行，从上向下顺序排列 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table等 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行 常用元素：span、a、i、em等 标准流是最基本的布局方式 19.3. 为什么需要浮动？有很多的布局效果，标准流没有办法完成，此时就可以利用浮动元素完成布局。因为浮动元素可以改变元素标签的默认排列方式。 浮动最典型的应用：可以让多个块级元素一行内排列显示。 网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。 19.4. 什么是浮动？float 属性用于创建浮动框，将其移动到一边，直到左边缘与右边缘触及包含块或另一个浮动框的边缘 语法： 123选择器 &#123; float: 属性值；&#125; 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 19.5. 浮动特性加了浮动之后的元素，会具有很多特性。 19.5.1. 浮动元素会脱离标准流（脱标）设置了浮动（float）的元素最重要特性： 脱离标准普通流的控制（浮）移动到指定位置（动）（俗称脱标） 浮动的盒子不再保留原先的位置 19.5.2. 浮动元素会一行内显示并且元素顶部对齐​ 注意：浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。 19.5.3. 浮动元素会具有行内块元素的特性任何元素都可以浮动。不管原来是什么模式的元素，添加浮动之后具有行内块元素相似的特性 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定 浮动的盒子中间没有缝隙，是紧挨在一起的 行内元素同理 19.6. 浮动元素经常和标准流父级搭配使用为了约束浮动元素位置，我们网页布局一般采取的策略是： 先用标准的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。符合网页布局第一准则 网页布局第二准则：先设置何盒子的大小，之后设置盒子的位置 20. 常见网页布局20.1. 常见网页布局20.2. 浮动布局注意点 浮动和标准流的父盒子搭配 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置 一个元素浮动了，理论上其余的兄弟也要浮动 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流 20.3. 清除浮动20.3.1. 为什么清除浮动由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占位置，最后父盒子高度为0时，就会影响下面的标准流盒子 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 20.3.2. 清除浮动本质： 清除浮动的本质时清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 语法： 123选择器 &#123; clear: 属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 实际工作中，只用 clear: both; 清除浮动的策略：闭合浮动（只让浮动在父盒子内部影响，不影响父盒子外面的其它盒子） 20.3.3. 清除浮动方法： 额外标签法 也称为隔墙法，是 W3C 推荐的做法 父级添加 overflow 属性 父级添加 after 伪元素 父亲添加双伪元素 20.3.4. 清除浮动——额外标签法额外标签法也称为隔墙法，是 W3C 推荐的做法 额外标签法会在浮动元素末尾添加一个空的标签。例如 &lt;div style=”clear: both”&gt;&lt;/div&gt;，或者其它标签（如&lt;br /&gt;等） 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化较差 注意：要求新的空标签必须是块级元素 20.3.5. 清除浮动——父级添加 overflow可以给父级添加 overflow 属性，将其属性值设置为 hidden、auto 或 scroll 优点：代码简洁 缺点：无法显示溢出的部分 20.3.6. 清除浮动——:after 伪元素法:after 方式是额外标签法的升级版。也是给父元素添加 12345678910.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123; /* IE6、7专有 */ *zoom: 1;&#125; 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站：百度、淘宝、网易等 20.3.7. 清除浮动——双伪元素法也是给父元素添加 12345678910.clearfix:before, .clearfix:after &#123; content: &quot;&quot;; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 20.4. 清除浮动总结20.4.1. 为什么要清除浮动？ 父级没高度 子盒子浮动 影响下面布局 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差 父级 overflow: hidden; 书写简单 溢出隐藏 父级 :after 伪元素 结构语义化正确 由于IE6/7不支持 :after，兼容性检查 父级双伪元素 结构语义化正确 由于IE6/7不支持 :after，兼容性检查 21.PS切图21.1. 常见的图片格式 jpg图像格式：JPEG（JPG）对色彩的信息保存较好，高清，颜色较多，产品的图片经常用 jpg 格式 gif图像格式：GIF 格式最多只能存储256色，所以通常用来显示简单图形和字体，但是可以保存透明背景和动画效果，实际经常用于一些图片小动画效果。 png图像格式是一种新兴的网络图形格式，结合了 GIF 和 JPEG 的优点，具有存储形式丰富的特点，能够保持透明背景。如果想要切成背景透明的图片，选择 png 格式 PSD 图像格式是 PS 的转义格式，里面可以存放图层、通道、遮罩等多种设计稿。对于前端人员，最大的优点，可以直接从上面复制文字，测量大小和距离。 21.2. 图层切图最简单的方法：右击图层 → 快速导出为 PNG。 但是很多情况下，我们需要合并图层再导出： 选中需要的图层：图层菜单 → 合并图层（Ctrl + E） 右击 → 快速导出为 PNG 21.3. 切片切图 利用切片选中图片 利用切片工具手动划出 导出选中的图片 文件菜单 → 导出 → 存储为web设备所用格式 → 选择图片格式 → 存储 21.4. PS插件切图Cutterman 是一款运行在 PS 中的软件，能够自动将你需要的图层进行输出，以替代传统的手工“导出 web 所用格式”以及使用切片工具进行挨个切图的繁琐过程。 22. 学成在线案例22.1. 准备素材工具 学成在线 PSD 源文件 开发工具 = PS（切图）/ cutterman插件 + vscode（代码）+ Chrome（测试） 22.2. 案例准备工作采取结构样式相分离 创建 study 目录文件夹（用于存放相关内容） 用 vscode 打开目录文件夹 study 目录内新建 images 文件夹，用于保存图片 新建首页文件 index.html 新建 style.css 样式文件。 将样式引入到 HTML 页面文件中 样式表写入清除内外边距样式，检测样式表是否引入成功 22.3. CSS属性书写顺序建议遵循以下顺序： 布局定位属性：display/position/float/clear/visibility/overflow（建议display第一个写，毕竟关系到模式） 自身属性：width/height/margin/padding/border/background 文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word 其他属性（CSS3）：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient… 12345678910111213.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; color: #333; background: rgba(0, 0, 0, .5); border-radius: 10px; &#125; 22.4. 页面布局整体思路为了提高网页制作的效率，布局时通常有以下的整体思路： 必须确认页面的版心（可视区）。 分析页面中的行模块，以及每个行模块中的列模块。页面布局第一准则。 一行中的列模块经常浮动布局，先确认每个列的大小，之后确认列的位置。页面布局第二准则。 制作HTML结构。我们还是遵循，现有结构，后有样式的原则。结构最重要。 先清楚布局结构，再写代码。 22.5. 确认版心这个页面的版心是 1200px，每个版心都要水平居中对齐，可以定义版心为公共类 1234.w &#123; width: 1200px; margin: auto;&#125; 22.6. 头部制作 1号是版心盒子 header 1200*42 的盒子水平居中对齐，上下给一个 margin 值就可以 版心盒子里面包含2号盒子 logo 版心盒子里面包含3号盒子 nav 导航栏 版心盒子里面包含4号盒子 search 搜索栏 版心盒子里面包含5号盒子 user 个人信息 注意：要求里面的4个盒子必须都是浮动 导航栏注意点： 实际开发中，我们不会直接用链接a，而是用li包含链接（li + a）的做法 li + a 语义更清晰，一看这就是有条理的列表项内容 如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎降权的风险），从而影响网站排名。 注意： 让导航栏一行显示，给 li 加浮动，因为 li 是块级元素，需要一行显示 nav 导航栏可以不给宽度，将来可以继续添加其余文字 因为导航栏里面的文字不一样多，所以最好给链接 a 左右 padding 撑开盒子，而不是指定宽度 22.7. banner 制作 1号盒子是通栏的大盒子，不给宽度，给高度，给一个背景颜色 2号盒子是版心，要水平居中对齐 3号盒子版心内，左对齐 subnav 侧导航栏 4号盒子版心内，右对齐 course 课程 22.8. 精品推荐小模块 大盒子水平居中 goods 精品，注意此处有盒子阴影 1号盒子是标题 H3 左侧浮动 2号盒子里面放链接左侧浮动，goods-item 距离可以控制链接的左右外边距（注意行内元素只给左右内外边距） 3号盒子右浮动 mod 修改 22.9. 精品推荐大模块 1号盒子为最大的盒子，box 版心水平居中对齐 2号盒子为上面部分，box-hd –里面左侧标题 H3 左浮动，右侧链接 a 右浮动 3号盒子为底下部分，box-bd –里面是无序列表，有10个小 li 组成 小 li 外边距的问题，这里有个小技巧：给 box-bd 宽度为1215 就可以一行装开5个 li 22.10. 底部模块 1号盒子是通栏大盒子，底部 footer 给高度，底色是白色 2号盒子版心水平居中 3号盒子版权 copyright 左对齐 4号盒子链接组 links 右对齐 23. 定位23.1. 为什么需要定位 浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子。 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子 23.2. 定位组成定位：将盒子定在某一位置，所以定位也是在摆放盒子，按照定位的方式移动盒子。 定位 = 定位模式 + 边偏移 定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置 23.2.1. 定位模式定位模式决定元素的定位方式，它通过 CSS 的 position 属性来设置，其值可以分为四个： 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 23.2.2. 边偏移边偏移就是定位的盒子移动到最终位置。有 top、bottom、left 和 right 4个属性 边偏移属性 示例 描述 top top: 80px; 顶部偏移量，定义元素相对于其父元素上边线的距离 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离 left left: 80px; 左侧偏移量，定义元素相对于其父元素左边线的距离 right right: 80px; 右侧偏移量，定义元素相对于其父元素右边线的距离 23.3. 静态定位 static静态定位是元素的默认定位方式，无定位的意思 语法： 1选择器 &#123; position: static; &#125; 静态定位按照标准流特性摆放位置，它没有边偏移 静态布局在布局中很少用到 23.4. 相对定位 relative相对定位是元素在移动的时候，是相对于它原来的位置（自恋型） 语法： 1选择器 &#123; position: relative; &#125; 它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置） 原来的标准流位置继续占有，后面的盒子仍然以标准流的方式对待它。（不脱标，继续保留原来位置） 因此，相对定位并没有脱标。它最典型的应用是给绝对定位当爹 23.5. 绝对定位 absolute绝对定位是元素在移动位置的时候，是相对于它祖先元素来说的（拼爹型）。 语法： 1选择器 &#123; position: absolute; &#125; 绝对定位的特点： 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位（Document文档） 如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置 绝对定位不再占有原先的位置（脱标） 23.6. 子绝父相的由来子级是绝对定位的话，父级要用相对定位 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其它的兄弟盒子 父盒子需要加定位限制子盒子在父盒子内显示 父盒子布局时，需要占有位置，因此父亲只能是相对定位。 这就是子绝父相的由来，所以相对定位经常用来作为绝对定位的父级。 总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位。 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到 23.7. 固定定位 fixed固定定位是元素固定于浏览器可视区的位置。主要应用场景：可以在浏览器页面滚动时元素的位置不会改变。 语法： 1选择器 &#123; position: fixed; &#125; 固定定位的特点： 以浏览器的可视窗口为参照点移动元素、和父元素没有关系、不随滚动条滚动 固定定位不占有原先的位置 固定定位也是脱标的，其实固定定位也可以看作是一种特殊的绝对定位 固定定位小技巧：固定在版心右侧位置 算法： 让固定定位的盒子 left: 50%，走到浏览器可视区（也可以看做版心）的一半位置 让固定定位的盒子 margin-left：版心宽度的一半距离。多走版心宽度的一半位置 23.8. 粘性定位 sticky粘性定位可以被认为是相对定位和固定定位的混合。 语法： 1选择器 &#123; position: sticky; top: 10px; &#125; 粘性定位的特点： 以浏览器的可视窗口为参照点移动元素（固定定位特点） 粘性定位占有原先的位置（相对定位特点） 必须添加 top、left、right、bottom 其中一个才有效 跟页面滚动搭配使用。兼容性较差，IE不支持。 23.9. 定位总结 定位模式 是否脱标 移动位置 是否常用 static 静态定位 否 不能使用边偏移 很少 relative 相对定位 否（占有位置） 相对于自身位置移动 常用 absolute 绝对定位 是（不占有位置） 当有定位的父级 常用 fixed 固定定位 是（不占有位置） 浏览器可视区 常用 sticky 粘性定位 否（占有位置） 浏览器可视区 当前阶段少 23.10. 定位叠放次序 z-index在使用定位布局的时候，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序（z轴） 语法： 1选择器 &#123; z-index: 1; &#125; 数值可以是正整数、负整数或0，默认是 auto，数值越大，盒子越靠上 如果属性值相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有 z-index 属性 23.11. 定位的拓展23.11.1. 绝对定位的盒子居中加了绝对定位的盒子不能通过 margin: 0 auto; 水平居中，但是可以通过以下计算方法实现水平和垂直居中 left: 50%; 让盒子的左侧移动到父级元素的水平中心位置 margin-left: -100px; 让盒子向左移动自身宽度的一半 23.11.2. 定位特殊特性绝对定位和固定定位也和浮动类似。 行内元素添加绝对或者固定定位，可以设置高度和宽度 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小 23.11.3. 脱标的盒子不会触发外边距塌陷浮动元素、绝对定位（固定定位）元素都不会触发外边距合并的问题 23.11.4. 绝对定位（固定定位）会完全压住盒子浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片） 但是绝对定位（固定定位）会压住下面标准流所有的内容 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。文字会围绕浮动元素 24. 网页布局总结通过盒子模型，清除知道大部分 html 标签是一个盒子 通过 CSS 浮动、定位可以让每个盒子排列成为网页 一个完整的网页，是标准流，浮动，定位一起完成布局的，每个都有自己的专门用法 标准流 可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局 浮动 可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局 定位 定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就用定位布局。 25.元素的显示与隐藏本质：让一个元素在页面中隐藏或者显示出来 25.1. display 显示隐藏display 属性用于设置一个元素应如何显示 display: none; 隐藏对象 display: block; 除了转换为块级元素之外，同时还有显示元素的意思。 display 隐藏元素后，不再占有原来的位置 搭配 JS 可以做很多的网页特效 25.2. visibility 可见性visibility 属性用于指定一个元素应可见还是隐藏 visibility: visible; 元素可见 visibility: hidden; 元素隐藏 visibility 隐藏元素后，继续占有原来的位置 25.3. overflow 溢出overflow 属性指定了内容溢出一个元素的框（超过其指定高度及宽度）时，会发生什么。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。 但是如果有定位的盒子，请慎用 overflow: hidden 因为它会隐藏多余的部分","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.milla.club/tags/CSS/"},{"name":"WEB","slug":"WEB","permalink":"http://www.milla.club/tags/WEB/"}]},{"title":"HTML","slug":"HTML","date":"2019-06-12T12:11:01.000Z","updated":"2020-04-21T06:13:06.195Z","comments":true,"path":"2019/06/12/HTML/","link":"","permalink":"http://www.milla.club/2019/06/12/HTML/","excerpt":"WEB 简介1. 网页1.1. 什么是网页网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 网页时网站的一“页”，通常是 HTML 格式的文件，它要浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此其俗称为 HTML 文件。","text":"WEB 简介1. 网页1.1. 什么是网页网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 网页时网站的一“页”，通常是 HTML 格式的文件，它要浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页，常见以 .htm 或 .html 后缀结尾的文件，因此其俗称为 HTML 文件。 1.2. 什么是HTMLHTML 指的是超文本标记语言（Hyper Text Markup Language），它是用来描述网页的一种语言。 HTML 不是一种编程语言，而是一种标记语言（markup language）。 标记语言是一套标记标签（markup tag）。 超文本： 它可以加入图片、声音、动画、多媒体等内容（超越了文本限制）。 它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本）。 1.3. 网页的形成网页是由网页元素组成的，这些元素是利用 html 标签描述出来，然后通过浏览器解析来显示给用户的。 前端代码 —— 浏览器显示代码（解析、渲染） —— 生成web页面 2. 常用浏览器浏览器是网页显示、运行的平台。常用的浏览器由 IE、火狐（Firefox）、谷歌（Chrome）、Safari 和 Opera 等。 浏览器内核浏览器内核（渲染引擎）：负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。 浏览器 内核 备注 IE Trident IE、猎豹安全、360极速浏览器、百度浏览器 Firefox Gecko 火狐浏览器内核 Safari WebKit 苹果浏览器内核 Chrome/Opera Blink chrome/opera 浏览器内核。Blink 其实是 WebKit 的分支 3. WEB标准Web标准是由 W3C 组织和其他标准化组织制订的一系列标准的集合。W3C（万维网联盟）是国际最著名的标准化组织。 3.1. 为什么需要 Web 标准浏览器不同，它们显示页面或者排版就有些许差异。 遵循Web标注除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 让 Web 的发展前景更广阔 内容能被更广泛的设备访问 更容易被搜索引擎搜索 降低网站的维护费用 使网站更易于维护 提高页面浏览速度 3.2. Web标准的构成主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面 标准 说明 结构（Structure） 结构用于对网页元素进行整理和分类，现阶段主要学的是 HTML 表现（Presentation） 表现用于设置网页元素的版式、颜色、大小等外观样式，主要是指 CSS 行为（Behavior） 行为是指网页模型的定义及交互的编写，现阶段主要学的是 JavaScript Web 标准提出的最佳体验方案：结构、样式、行为相分离。 简单理解：结构写到 HTML 文件中，表现写到 CSS 文件中，行为写到 JavaScript 文件中。 HTML1. HTML语法规范1.1. 基本语法概述 HTML 标签是由尖括号包围的关键词，例如 &lt;html&gt;。 HTML 标签通常是成对出现的，例如 &lt;html&gt; 和 &lt;/html&gt;，我们称为双标签。标签对中的第一个标签是开始标签，第二个标签是结束标签 有些特殊的标签必须是单个标签（极少情况），例如 &lt;br /&gt;，我们称之为单标签。 1.2. 标签关系双标签关系可以分为两类：包含关系和并列关系 包含关系： 123&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 并列关系： 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 2. HTML基本结构标签2.1. 第一个HTML网页每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。 HTML 页面也称为 HTML 文档 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我是第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 床前明月光，疑是地上霜。 &lt;/body&gt;&lt;/html&gt; 标签名 定义 说明 &lt;html&gt;&lt;/html&gt; HTML 标签 页面中最大的标签，我们称为根标签 &lt;head&gt;&lt;/head&gt; 文档的头部 注意在 head 标签中我们必须要设置的标签是 title &lt;title&gt;&lt;/title&gt; 文档的标题 让页面拥有一个属于自己的网页标题 &lt;body&gt;&lt;/body&gt; 文档的主体 元素包含文档的所有内容，页面内容基本都是放到 body 里面的 HTML 文档的后缀必须是 .html 或 .htm，浏览器的作用是读取 HTML 文档，并以网页的形式显示它们。 2.2. 基本结构标签总结3. 网页开发工具3.1. 文档类型声明标签&lt;!DOCTYPE&gt; 文档类型声明，作用就是告诉浏览器使用哪种 HTML 版本来显示网页。 1&lt;!DOCTYPE html&gt; 这句代码的意思是：当前页面采取的是 HTML5 版本来显示网页 注意： &lt;!DOCTYPE&gt; 声明位于文档中的最前面位置，处于 &lt;html&gt;标签之前 &lt;!DOCTYPE&gt; 不是一个 HTML 标签，它就是文档类型声明标签 3.2. lang 语言种类用来定义当前文档显示的语言。 en 定义语言为语言 zh-cn 定义语言文中文 简单来说，定义 en 就是英文网页，定义 zh-cn 就是中文网页 其实对于文档显示来说，定义为 en 的文档也可以显示中文，定义为 zh-cn 的文档也可以显示英文 这个属性对浏览器和搜索引擎（百度、谷歌等）有作用。 12&lt;html lang=&quot;en&quot;&gt;&lt;/html&gt; 3.3. 字符集字符集（Character set）是多个字符的集合。以便计算机能够识别和存储各类文字。 在&lt;head&gt;标签内，可以通过 &lt;meta&gt; 标签的 charset 属性来规定 HTML 文档应该使用哪种字符编码。 1&lt;meta charset=&quot;UTF-8&quot;&gt; charset 常用的值有：GB2312、BIG5、GBK 和 UTF-8，其中 UTF-8 也被称为万国码，基本包含了全世界所有国家需要用到的字符。 注意： 上面语法是必须要写的代码，否则可能引起乱码的情况。一般情况下，统一使用 “UTF-8” 编码，尽量统一写成标准的 “UTF-8”，不要写成 “utf8” 或 “UTF8”。 4. HTML常用标签4.1. 标签语义标签的含义 4.2. 标题标签 &lt;h1&gt; - &lt;h6&gt;为了使网页更具有语义化，我们经常会在页面中用到标题标签。HTML 提供了6个等级的网页标题，即 &lt;h1&gt; - &lt;h6&gt;。 1&lt;h1&gt;一级标题&lt;/h1&gt; 单词 head 的缩写，以为头部、标题。 标签语义：作为标题使用，并且依据重要性递减 特点： 加了标题的文字会加粗，字号变大 一个标题独占一行 4.3. 段落和换行标签在网页中，要把文字有条理的显示出来，就需要将这些文字分段显示。在 HTML 标签中，&lt;p&gt; 标签用于定义段落，它可以将整个网页分为若干个段落。 1&lt;p&gt;段落标签&lt;/p&gt; 单词 paragraph 的缩写，意为段落。 标签语义：可以把 HTML 文档分割为若干个段落。 特点： 文本在一个段落中会根据浏览器窗口的大小自动切换 段落和段落中间保有空隙 在 HTML 中，一个段落中的文字从左到右会依次排列，直到浏览器窗口的右端，然后才自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br /&gt;。 1&lt;br /&gt; 单词 break 的缩写，意为打断、换行 标签语义：强制换行 特点： &lt;br /&gt; 是单标签 &lt;br /&gt; 标签只是简单的开始新的一行，和段落不一样，段落之间会插入一些垂直的间距 4.4. 文本格式化标签在网页中，有时需要为文字设置粗体、斜体或下划线等效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 标签语义：突出重要性，比普通文字更重要。 语义 标签 加粗 &lt;strong&gt;&lt;/strong&gt; 或者 &lt;b&gt;&lt;/b&gt; 更推荐使用 &lt;strong&gt; 标签加粗，语义更强烈 倾斜 &lt;em&gt;&lt;/em&gt; 或者 &lt;i&gt;&lt;/i&gt; 更推荐使用 &lt;em&gt; 标签加粗，语义更强烈 删除线 &lt;del&gt;&lt;/del&gt; 或者 &lt;s&gt;&lt;/s&gt; 更推荐使用 &lt;del&gt; 标签加粗，语义更强烈 下划线 &lt;ins&gt;&lt;/ins&gt; 或者 &lt;u&gt;&lt;/u&gt; 更推荐使用 &lt;ins&gt; 标签加粗，语义更强烈 4.5. &lt;div&gt;&lt;/div&gt; 和 &lt;span&gt;&lt;/span&gt; 标签&lt;div&gt; 和 &lt;span&gt; 是没有语义的，它们就是一个盒子，用来装内容的。 12&lt;div&gt;这是一个盒子&lt;/div&gt;&lt;span&gt;这也是一个盒子&lt;/span&gt; div 是 division 的缩写，表示分割、分区。 span 意为跨度、跨距。 特点： &lt;div&gt; 标签用来布局，但是在一行只能放一个 &lt;div&gt;。大盒子 &lt;span&gt; 标签用来布局，一行上可以多个 &lt;span&gt;。小盒子 4.6. 图像标签和路径4.6.1. 图像标签在HTML标签中，&lt;img&gt; 标签用于定义 HTML 页面中的图像。 1&lt;img src=&quot;图像URL&quot; /&gt; 单词 image 的缩写，意为图像。 src 是 &lt;img&gt; 标签的必须属性，它用于指定图像文件的路径和文件名。 所谓属性：简单理解就是属于这个图像标签的特性。 图像标签的其他属性： 属性 属性值 说明 src 图片路径 必须属性 alt 文本 替换文本。图像不能显示的文字 title 文本 提示文本。鼠标放到图像上，显示的文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框粗细 1234567891011121314&lt;body&gt;&lt;div&gt;图像&lt;/div&gt;&lt;img src=&quot;imgs/img2.jpg&quot; /&gt;&lt;div&gt;alt 替换文本 图像显示不出来文字替换&lt;/div&gt;&lt;img src=&quot;img/img2.jpg&quot; alt=&quot;美女&quot; /&gt;&lt;div&gt;title 提示文本 图标放到图片上，提示的文字&lt;/div&gt;&lt;img src=&quot;imgs/img2.jpg&quot; alt=&quot;美女&quot; title=&quot;美女西施&quot; /&gt;&lt;div&gt;width 设定宽度&lt;/div&gt;&lt;img src=&quot;imgs/img2.jpg&quot; alt=&quot;美女&quot; title=&quot;美女西施&quot; width=&quot;500&quot; /&gt;&lt;div&gt;height 设定高度&lt;/div&gt;&lt;img src=&quot;imgs/img2.jpg&quot; alt=&quot;美女&quot; title=&quot;美女西施&quot; height=&quot;200&quot; /&gt;&lt;div&gt;height 设定边框&lt;/div&gt;&lt;img src=&quot;imgs/img2.jpg&quot; alt=&quot;美女&quot; title=&quot;美女西施&quot; border=&quot;15&quot; /&gt;&lt;/body&gt; 图像标签属性注意点： 图像标签可以拥有多个属性，必须写在标签名的后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 属性采取键值对形式，即 key = “value” 的格式，属性 = “属性值”。 4.6.2. 路径目录文件夹和根目录： 实际工作中，文件不能随便乱放，否则用起来很难快速找到它们，因此需要一个文件夹来管理。 目录文件夹：就是普通文件夹，里面只不过存放了页面所需要的相关素材，比如 html 文件、图片等。 根目录：打开目录文件夹的第一次就是根目录 页面中的图片会非常多，通常我们会新建一个文件夹来存放这些图像文件（images），这时再查找图像，就需要采取“路径”的方式来指定图像文件的位置。 路径可以分为： 相对路径 绝对路径 相对路径：以引用文件所在位置为参考基础，而建立出的目录路径。 相对路径分类 符号 说明 同一级路径 图像文件位于HTML文件的同一级 如&lt;img src=”baidu.gif” /&gt; 下一级路径 / 图像文件位于HTML文件的下一级 如&lt;img src=”images/baidu.gif” /&gt; 上一级路径 ../ 图像文件位于HTML文件的上一级 如&lt;img src=”../baidu.gif” /&gt; 绝对路径：是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。 4.7. 超链接标签在 HTML 标签中，&lt;a&gt; 标签用于定义超链接，作用是从一个页面链接到另一个页面 链接的语法格式 1&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt; 单词 anchor 的缩写，意为：锚 两个属性的作用如下： 属性 作用 href 用于指定链接目标的地址，（必须属性）当为标签应用 href 属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其中 _self 为默认值，_blank 为在新窗口中打开方式 链接分类： 外部链接，例如 &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; 内部链接，网站内部页面之间的相互链接，直接链接内部页面名称即可，例如 &lt;a href=&quot;index.html&quot;&gt;首页&lt;/a&gt; 空链接：如果当时没有确定链接目标时，&lt;a href=&quot;#&quot;&gt;首页&lt;a&gt; (点击链接，页面默认上滚到页的顶部， 但可以加上 onclick=”return false”，防止上滚到页的顶部。) &lt;a href=&quot;javascript: void(0);&quot;&gt;test&lt;/a&gt; &lt;a href=&quot;javascript:;&quot;&gt;test&lt;/a&gt; 死链接，指向空事件 下载链接：如果 href 里面地址是一个文件或者压缩包，会下载这个文件 网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以添加超链接 锚点链接：点击链接，可以快速定位到页面中的某个位置 在链接文本的 href 属性中，设置属性值为 #名字 的形式，如 &lt;a href=&quot;#two&quot;&gt;第2集&lt;/a&gt; 找到目标位置标签，里面添加一个 id属性 = 刚才的名字，如 &lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt; 1234567891011121314151617&lt;body&gt;&lt;h4&gt;1.外部链接&lt;/h4&gt;&lt;a href=&quot;http://www.qq.com&quot; target=&quot;_blank&quot;&gt;tencent&lt;/a&gt;&lt;!--target 打开窗口的方式，默认的值是_self，当前页面打开页面；_blank，新窗口打开页面--&gt; &lt;h4&gt;2.内部链接：网站内部页面之间相互链接&lt;/h4&gt;&lt;a href=&quot;07_图像标签.html&quot;&gt;图像标签&lt;/a&gt;&lt;h4&gt;3.空链接：#&lt;/h4&gt;&lt;a href=&quot;#&quot;&gt;空链接&lt;/a&gt;&lt;h4&gt;4.下载链接：地址链接是文件 .exe 或者是 zip 等压缩包&lt;/h4&gt;&lt;a href=&quot;imgs/img2.rar&quot;&gt;下载文件&lt;/a&gt;&lt;h4&gt;5.网页元素链接&lt;/h4&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;&lt;img src=&quot;imgs/img2.jpg&quot;&gt;&lt;/a&gt;&lt;/body&gt; 5. HTML中的注释和特殊字符5.1. 注释如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示的注释文字，就需要使用注释标签。 HTML 的注释以 &lt;!-- 开头，以 --&gt; 结束。 1&lt;!--我是一个注释--&gt; &lt;!--快捷键：ctrl + / --&gt; 添加注释是为了更好的解释代码的功能，便于相关开发人员理解和阅读代码，程序是不会执行注释内容的。 5.2. 特殊字符在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。 特殊字符 描述 字符的代码 空格符 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; ￥ 人民币 &amp;yen; © 版权 &amp;copy; ® 注册商标 &amp;reg; ° 摄氏度 &amp;deg; ± 正负号 &amp;plusmn; × 乘号 &amp;times; ÷ 除号 &amp;divide; ² 平方2（上标2） &amp;sup2; ³ 立方3（上标3） &amp;sup3; 6. 表格标签6.1. 表格的主要作用表格主要用来显示、展示数据，因为它可以让数据显示的非常的规整，可读性非常好。特别是后台展示数据的时候，能够熟练运用表格就显得很重要。一个清爽简约的表格能够把繁杂的数据表现得很有条理。 表格用来展示数据。 6.2. 表格的基本语法1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; &lt;table&gt;&lt;/table&gt; 是用来定义表格的标签 &lt;tr&gt;&lt;/tr&gt; 标签定义表格中的行，必须嵌套在 &lt;table&gt;&lt;/table&gt; 标签中 &lt;td&gt;&lt;/td&gt;用于定义表格中的单元格，必须嵌套在 &lt;tr&gt;&lt;/tr&gt; 标签中 字母 td 指表格数据（table data），即数据单元格的内容 6.3. 表头单元格标签一般表头单元格位于表格的第一行或第一列，表头单元格里面的文字内容加粗居中显示。 &lt;th&gt; 标签表示 HTML 表格的表头部分（table head的缩写） 1234567&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 6.4. 表格属性表格标签这部分属性我们实际开发中不常用，后面通过 CSS 来设置。 属性名 属性值 描述 align left、center、right 规定表格相对周围元素的对齐方式 border 1 或 “” 规定表格单元是否拥有边框，默认为 “”，表示没有边框 cellpadding 像素值 规定单元边沿与其内容之间的空白，默认1像素 cellspacing 像素值 规定单元格之间的空白，默认2像素 width 像素值或百分比 规定表格的宽度 小说排名案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;body&gt;&lt;table align=&quot;center&quot; cellspacing=&quot;0&quot; cellpadding=&quot;10px&quot; border=&quot;1px&quot; width=&quot;700px&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;关键词&lt;/th&gt; &lt;th&gt;趋势&lt;/th&gt; &lt;th&gt;今日搜索&lt;/th&gt; &lt;th&gt;最近七日&lt;/th&gt; &lt;th&gt;相关链接&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;鬼吹灯&lt;/td&gt; &lt;td&gt;↓&lt;/td&gt; &lt;td&gt;345&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;盗墓笔记&lt;/td&gt; &lt;td&gt;↓&lt;/td&gt; &lt;td&gt;124&lt;/td&gt; &lt;td&gt;675423&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;西游记&lt;/td&gt; &lt;td&gt;↑&lt;/td&gt; &lt;td&gt;321&lt;/td&gt; &lt;td&gt;43242&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;三国演义&lt;/td&gt; &lt;td&gt;↑&lt;/td&gt; &lt;td&gt;342&lt;/td&gt; &lt;td&gt;43242&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;甄嬛传&lt;/td&gt; &lt;td&gt;↓&lt;/td&gt; &lt;td&gt;11&lt;/td&gt; &lt;td&gt;34325&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;6&lt;/td&gt; &lt;td&gt;老人与海&lt;/td&gt; &lt;td&gt;↑&lt;/td&gt; &lt;td&gt;32&lt;/td&gt; &lt;td&gt;231&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;7&lt;/td&gt; &lt;td&gt;水浒传&lt;/td&gt; &lt;td&gt;↑&lt;/td&gt; &lt;td&gt;213&lt;/td&gt; &lt;td&gt;43243&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;贴吧&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;图片&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;百科&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt; 6.5. 表格结构标签使用场景：因为表格可能很长，为了更好的表示表格的语义，可以将表格分割成表格头部和表格主体两大部分 在表格标签中，分别用：&lt;thead&gt; 标签 表格的头部区域、&lt;tbody&gt; 标签 表格的主体区域。 &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。&lt;thead&gt; 内部必须拥有 &lt;tr&gt; 标签。一般是位于第一行。 &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主题，主要用于放数据本体 以上两个标签都是放在 &lt;table&gt;&lt;/table&gt; 标签中 1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; ... &lt;/tbody&gt; &lt;tfoot&gt; ... &lt;/tfoot&gt;&lt;/table&gt; 6.6. 合并单元格特殊情况下，可以把多个单元格合并为一个单元格。 合并单元格方式： 跨行合并：rowspan=&quot;合并单元格的个数&quot; 跨列合并：colspan=&quot;合并单元格的个数&quot; 目标单元格：（写合并代码） 跨行：最上侧单元格为目标单元格，写合并代码 跨列：最左侧单元格为目标单元格，写合并代码 合并单元格三部曲： 先确定是跨行还是跨列合并 找到目标单元格。写上合并方式 = 合并的单元格数量 删除多余的单元格 7. 列表标签列表用来布局 特点：整齐、整洁、有序，它作为布局会更加自由和方便 7.1. 无序列表&lt;ul&gt; 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 &lt;li&gt; 标签定义。 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ...&lt;/ul&gt; 无序列表的各个列表项之间没有顺序级别之分，是并列的 &lt;ul&gt;&lt;/ul&gt; 中只能嵌套 &lt;li&gt;&lt;/li&gt;，直接在 &lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或文字的做法是不被允许的 &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素 无序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置 7.2. 有序列表有序列表即为有排列顺序的列表，其各个列表项会按照一定的顺序排列定义。 在 HTML 标签中，&lt;ol&gt; 标签用于定义有序列表，列表排序以数字来显示，并且使用 &lt;li&gt; 标签来定义列表项 123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ...&lt;/ol&gt; &lt;ol&gt;&lt;/ol&gt; 中只能嵌套 &lt;li&gt;&lt;/li&gt;，直接在 &lt;ol&gt;&lt;/ol&gt; 标签中输入其他标签或文字的做法是不被允许的 &lt;li&gt; 与 &lt;/li&gt; 之间相当于一个容器，可以容纳所有元素 有序列表会带有自己的样式属性，但在实际使用时，我们会使用 CSS 来设置 7.3. 自定义列表自定义列表的使用场景 自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号 在 HTML 标签中，&lt;dl&gt; 标签用于定义描述列表（或定义列表），该标签会与 &lt;dt&gt;（定义项目/名字）和 &lt;dd&gt;（描述每一个项目/名字）一起使用。 123456&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ...&lt;/dl&gt; &lt;dl&gt;&lt;/dl&gt; 里面只能包含 &lt;dt&gt; 和 &lt;dd&gt; &lt;dt&gt; 和 &lt;dd&gt; 个数没有限制，经常是一个 &lt;dt&gt; 对应多个 &lt;dd&gt; 7.4. 列表总结 标签名 定义 说明 &lt;ul&gt;&lt;/ul&gt; 无序列表 里面只能包含 li，没有顺序，使用较多。li 里面可以包含任何标签 &lt;ol&gt;&lt;/ol&gt; 有序列表 里面只能包含 li，有顺序，使用相对较少。li 里面可以包含任何标签 &lt;dl&gt;&lt;/dl&gt; 自定义列表 里面只能包含 dt 和 dd。dt 和dd 里面以包含任何标签 8. 表单标签8.1. 为什么需要表单在网页中，需要与用户进行交互，收集用户资料，此时就需要表单 8.2. 表单的组成在 HTML 中，一个完整的表单通常由 表单域、表单控件（也称为表单元素）和 提示信息 3个部分组成 8.3. 表单域表单域是一个包含表单元素的区域 在 HTML 标签中，&lt;form&gt; 标签用于定义表单域，以实现用户信息的收集和传递 &lt;form&gt; 会把它范围内的表单元素信息提交给服务器 123&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单域的名称&quot;&gt; 各种表单元素控件&lt;/form&gt; 常用属性： 属性 属性值 作用 action url 地址 用于指定接收并处理表单数据的服务器程序的 url 地址 method get/post 用于设置表单数据的提交方式，其取值为 get 或 post name 名称 用于指定表单的名称，以区分同一个页面中的多个表单域 8.4. 表单控件（表单元素）在表单域中可以定义各种表单元素，这些表单元素就是允许用户在表单中输入或者选择的内容控件。 input 输入表单元素 select 下拉表单元素 textarea 文本域元素 8.4.1. &lt;input&gt;表单元素在英文单词中，input 是输入的意思，而在表单元素中 &lt;input&gt; 标签用于收集用户信息。 在 &lt;input&gt; 标签中，包含一个 type 属性，根据不同的 type 属性值，输入字段拥有很多种形式（可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等）。 1&lt;input type=&quot;属性值&quot; /&gt; &lt;input /&gt; 标签为单标签 type 属性设置不同的属性值用来指定不同的控件类型 type属性的属性值及其描述如下： 属性值 描述 button 定义可单击按钮（多数情况下，通过 JavaScript 启动脚本） checkbox 定义复选框 file 定义输入字段和“浏览”按钮，供文件上传 hidden 定义隐藏的输入字段 image 定义图像形式的提交按钮 password 定义密码字段。该字段中的字符被掩码 radio 定义单选按钮 reset 定义重置按钮。重置按钮会清除表单中的所有数据 submit 定义提交按钮。提交按钮会把表单数据发送到服务器 text 定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符 除 type 属性外，&lt;input&gt; 标签还有很多其他属性，其常用属性如下： 属性 属性值 描述 name 由用户自定义 定义 input 元素的名称 value 由用户自定义 规定 input 元素的值 checked checked 规定此 input 元素首次加载时应当被选中 maxlength 正整数 规定输入字段中的字符的最大长度 name 和 value 是每个表单元素都有的属性值，主要给后台人员使用 name 表单元素的名字，要求单选按钮和复选框要有相同的 name 值 checked 属性主要针对单选按钮和复选框，主要作用为打开页面时，就可以默认选中这个表单元素 maxlength 是用户可以在表单元素输入的最大字符数，一般较少使用。 12345678910111213141516171819202122&lt;form action=&quot;xxx.php&quot; method=&quot;get&quot;&gt; &lt;!--text 文本框，用户可以在里面输入任何字符--&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot; maxlength=&quot;6&quot;&gt;&lt;br /&gt; &lt;!--password 密码框 用户看不到密码--&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br /&gt; &lt;!--radio 单选按钮 可以实现多选一--&gt; &lt;!--name 是表单元素名字 这里性别单选按钮必须有相同的名字name，才能实现多选一--&gt; &lt;!--单选按钮和复选框可以设置checked属性，当页面打开的时候就可以默认选中这个按钮--&gt; 性别：男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot;&gt; 女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;br /&gt; &lt;!--checkbox 复选框 可以实现多选--&gt; 爱好：吃饭 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;吃饭&quot;&gt; 睡觉 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;睡觉&quot;&gt; 打豆豆 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打豆豆&quot;&gt;&lt;br /&gt; &lt;!--点击提交按钮，可以把表单域form里面的表单元素里面的值，提交给后台服务器--&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;!--重置按钮可以还原表单元素的默认状态--&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!--普通按钮 button 后期结合js搭配使用--&gt; &lt;input type=&quot;button&quot; value=&quot;获取短信验证码&quot;&gt;&lt;br /&gt; &lt;!--文件域 上传文件使用--&gt; 上传头像：&lt;input type=&quot;file&quot;&gt;&lt;/form&gt; 8.4.2. &lt;label&gt; 标签&lt;label&gt; 标签为 input 元素定义标注（标签）。 &lt;label&gt; 标签用于绑定一个表单元素，当点击 &lt;label&gt; 标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，增加用户体验 语法： 12&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt; 核心：&lt;label&gt; 标签的for属性应当与相关元素的id属性相同 12345&lt;body&gt;&lt;label for=&quot;user&quot;&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;user&quot; /&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt;&lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;famale&quot; /&gt;&lt;label for=&quot;famale&quot;&gt;女&lt;/label&gt;&lt;/body&gt; 8.4.3. &lt;select&gt; 表单元素使用场景：在页面中，如果有多个选项让用户选择，并且想要节约页面控件时，可以使用 &lt;select&gt; 标签控件定义下拉列表。 语法： 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; &lt;select&gt; 中至少包含一堆 &lt;option&gt; 在 &lt;option&gt; 中定义 selected=”selected” 时，当前项即为默认选中项 8.4.4. &lt;textarea&gt; 表单元素使用场景：当用户输入内容较多的情况下，我们就不能使用文本框表单了，此时可以使用 &lt;textarea&gt; 标签。 在表单元素中， &lt;textarea&gt; 标签时用于定义多行文本输入的控件 使用多行文本输入控件，可以输入更多的文字，该控件常见于留言板，评论。 语法： 123&lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt; 文本内容&lt;textarea&gt; 通过 &lt;textarea&gt; 标签可以轻松地创建多行文本输入框。 cols=”每行中的字符数”，rows=”显示的行数”，我们在实际开发中不会使用，都是用 css 来改变大小 8.5. 表单元素总结 表单元素 input 输入表单元素；select 下拉表单元素；textarea 文本域表单元素； 这三组表单元素都应该包含在 form 表单域里面，并且有 name 属性1234567&lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;select name=&quot;jiguan&quot;&gt; &lt;option&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;textarea name=&quot;message&quot;&gt;&lt;/textarea&gt;&lt;/form&gt; 有三个名字非常相似的标签：（1）表单域 form 使用场景：提交区域内表单元素给后台服务器（2）文件域 file，是input type属性值 使用场景：上传文件（3）文本域 textarea 使用场景：可以输入多行文字，比如留言板，网页介绍等 我们当前阶段不需要提交表单元素，所以我们只负责表单元素的外观形态即可 注册页面案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;body&gt;&lt;h4&gt;青春不常在，抓紧谈恋爱&lt;/h4&gt;&lt;table width=&quot;700px&quot;&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot;&gt; &lt;label for=&quot;male&quot;&gt;&lt;img src=&quot;images/nan.svg&quot;&gt;&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;female&quot;&gt; &lt;label for=&quot;female&quot;&gt;&lt;img src=&quot;images/nv.svg&quot;&gt;&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;生日&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;--请选择年--&lt;/option&gt; &lt;option&gt;1990&lt;/option&gt; &lt;option&gt;1991&lt;/option&gt; &lt;option&gt;1992&lt;/option&gt; &lt;option&gt;1993&lt;/option&gt; &lt;option&gt;1994&lt;/option&gt; &lt;option&gt;1995&lt;/option&gt; &lt;option&gt;1996&lt;/option&gt; &lt;option&gt;1997&lt;/option&gt; &lt;option&gt;1998&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;--请选择月--&lt;/option&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;option&gt;6&lt;/option&gt; &lt;option&gt;7&lt;/option&gt; &lt;option&gt;8&lt;/option&gt; &lt;option&gt;9&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;--请选择日--&lt;/option&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;option&gt;6&lt;/option&gt; &lt;option&gt;7&lt;/option&gt; &lt;option&gt;8&lt;/option&gt; &lt;option&gt;9&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;北京&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;婚姻状况&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot; id=&quot;weihun&quot; checked=&quot;checked&quot;&gt; &lt;label for=&quot;weihun&quot;&gt;未婚&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot; id=&quot;yihun&quot;&gt; &lt;label for=&quot;yihun&quot;&gt;已婚&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot; id=&quot;lihun&quot;&gt; &lt;label for=&quot;lihun&quot;&gt;离婚&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;学历&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;本科&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;喜欢的类型&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;type&quot; id=&quot;wm&quot;&gt; &lt;label for=&quot;wm&quot;&gt;妩媚的&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;type&quot; id=&quot;ka&quot;&gt; &lt;label for=&quot;ka&quot;&gt;可爱的&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;type&quot; id=&quot;xxr&quot;&gt; &lt;label for=&quot;xxr&quot;&gt;小鲜肉&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;type&quot; id=&quot;llr&quot;&gt; &lt;label for=&quot;llr&quot;&gt;老腊肉&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;type&quot; id=&quot;all&quot;&gt; &lt;label for=&quot;all&quot;&gt;都喜欢&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;自我介绍&lt;/td&gt; &lt;td&gt; &lt;textarea cols=&quot;20&quot; rows=&quot;2&quot;&gt;自我介绍&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot;&gt;我同意注册条款和会员加入标准&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;我是会员，立即登录&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;h4&gt;我承诺&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;年满18岁、单身&lt;/li&gt; &lt;li&gt;抱着严肃的态度&lt;/li&gt; &lt;li&gt;真诚寻找另一半&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"http://www.milla.club/tags/WEB/"},{"name":"HTML","slug":"HTML","permalink":"http://www.milla.club/tags/HTML/"}]},{"title":"TCP/IP协议","slug":"TCP-IP协议","date":"2019-04-19T12:21:34.000Z","updated":"2020-04-21T06:19:45.899Z","comments":true,"path":"2019/04/19/TCP-IP协议/","link":"","permalink":"http://www.milla.club/2019/04/19/TCP-IP%E5%8D%8F%E8%AE%AE/","excerpt":"从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。","text":"从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。 一、 计算机网络体系结构分层不难看出，TCP/IP 与 OSI 在分层模块上稍有区别。OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。 二、 TCP/IP 基础1. TCP/IP 的具体含义从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。 互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。 2. 数据包包、帧、数据包、段、消息 以上五个术语都用来表述数据的单位，大致区分如下： 包可以说是全能性术语； 帧用于表示数据链路层中包的单位； 数据包是 IP 和 UDP 等网络层以上的分层中包的单位； 段则表示 TCP 数据流中的信息； 消息是指应用协议中数据的单位。 每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。 3. 数据处理流程下图以用户 a 向用户 b 发送邮件为例子：① 应用程序处理 首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能； 编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。 ② TCP 模块的处理 TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。 ③ IP 模块的处理 IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。 ④ 网络接口（以太网驱动）的处理 从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。 ⑤ 网络接口（以太网驱动）的处理 主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。 如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。 ⑥ IP 模块的处理 IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。 另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。 ⑦ TCP 模块的处理 在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。***检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。 ⑧ 应用程序的处理 接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。 三、传输层中的 TCP 和 UDPTCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。 TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。 UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。 TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。 1. 端口号数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。 1.1 根据端口号识别应用一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。 1.2 通过 IP 地址、端口号、协议号进行通信识别仅凭目标端口号识别某一个通信是远远不够的。① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。 ③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。 此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。 1.3 端口号的确定 标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 01023之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 102449151 之间，不过这些端口号可用于任何通信用途。 时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在49152~65535 之间。 1.4 端口号与协议 端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。 此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。 2. UDP UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP也无法进行流量控制等避免网络拥塞行为。 此外，传输途中出现丢包，UDP 也不负责重发。 甚至当包的到达顺序出现乱序时也没有纠正的功能。 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。 UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN等特定网络中的应用通信；4.广播通信（广播、多播）。 3. TCP TCP 与 UDP的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP中都没有。 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。 3.1 三次握手（重点） TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。 下面来看看三次握手的流程图： 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。 3.2 四次挥手（重点） 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。 下面来看看四次挥手的流程图：中断连接端可以是客户端，也可以是服务器端。 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2状态，继续等待服务器端的FIN报文。 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。 上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。 具体流程如下图： 3.3 通过序列号与确认应答提高可靠性 在 TCP中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。 未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。 对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。 序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。 3.4 重发超时的确定 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。 TCP要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。 在 BSD 的 Unix 以及 Windows系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。 此外，数据也不会被***、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。 3.5 以段为单位发送数据 在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“消息长度”（MSS）。最理想的情况是，消息长度正好是IP 中不会被分片处理的***数据长度。 TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。 MSS在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入MSS选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。 3.6 利用窗口控制提高速度 TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。 为解决这个问题，TCP引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示： 窗口控制 窗口大小就是指无需等待确认应答而可以继续发送数据的***值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。 3.7 滑动窗口控制 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。 3.8 窗口控制中的重发控制在使用窗口控制中， 出现丢包一般分为两种情况： ① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。 四、网络层中的 IP 协议 IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。 网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。 IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。 1. IP 地址1.1 IP 地址概述 在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。 作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。 IP 地址（IPv4 地址）由32位正整数来表示。IP地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下： 1.2 IP 地址由网络和主机两部分标识组成 如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP地址都不会相互重叠。即 IP 地址具有了唯一性。 如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。 1.3 IP 地址的分类 IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。 A 类 IP 地址是首位以 “0” 开头的地址。从第 1 位到第 8位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。 B 类 IP 地址是前两位 “10” 的地址。从第 1 位到第 16位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。 C 类 IP 地址是前三位为 “110” 的地址。从第 1 位到第 24位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。 D 类 IP 地址是前四位为 “1110” 的地址。从第 1 位到第 32位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。 1.4 广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。 广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。 1.5 IP 多播 多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图： IP 多播 多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。 此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。 1.6 子网掩码 现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。 子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。 对于子网掩码，目前有两种表示方式。***种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26位是网络地址的情况为例，如下： 第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下： 2. 路由 发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。 该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。 IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。 2.1 IP 地址与路由控制 IP 地址的网络地址部分用于进行路由控制。 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。 在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。 3. IP 分包与组包 每种数据链路的***传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。 任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。 经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。 3.1 路径 MTU 发现 分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。 为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是*** MTU的大小。即路径中存在的所有数据链路中最小的 MTU 。 进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。 4. IPv6 IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。 4.1 IPv6 的特点 IP 得知的扩大与路由控制表的聚合。 性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。 支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。 采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。 多播、Mobile IP 成为扩展功能。 4.2 IPv6 中 IP 地址的标记方法 一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。 而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。 4.3 IPv6 地址的结构 IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。 在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。 4.4 全局单播地址 全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。 格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64比特为网络标识，后 64 比特为主机标识。 4.5 链路本地单播地址 链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC地址。 4.6 唯一本地地址 唯一本地地址是不进行互联网通信时所用的地址。 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。 L 通常被置为 1 全局 ID 的值随机决定 子网 ID 是指该域子网地址 接口 ID 即为接口的 ID 4.7 IPv6 分段处理 IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。 IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。 4.8 IP 首部（暂略）5. IP 协议相关技术 IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。 5.1 DNS 我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP地址。 这种 DNS 不仅适用于 IPv4，还适用于 IPv6。 5.2 ARP 只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的MAC 地址。 ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。 RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。 5.3 ICMP ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。 IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。 5.4 DHCP 如果逐一为每一台主机设置 IP地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。 于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。 DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。 5.5 NAT NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP地址的技术。 除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address PortsTranslator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。 NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。 5.6 IP 隧道 如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。 IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。 一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://www.milla.club/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"关于HTTP协议","slug":"关于HTTP协议","date":"2019-04-19T10:22:16.000Z","updated":"2020-04-21T06:20:52.286Z","comments":true,"path":"2019/04/19/关于HTTP协议/","link":"","permalink":"http://www.milla.club/2019/04/19/%E5%85%B3%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE/","excerpt":"HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。","text":"HTTP简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 5、支持B/S及C/S模式。 HTTP之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分： 1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 （原文：http://blog.csdn.net/ergouge/article/details/8185219 ） URI和URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的 URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:&#106;&#97;&#118;&#x61;&#x2d;&#x6e;&#101;&#116;&#x40;&#106;&#97;&#x76;&#x61;&#46;&#x73;&#x75;&#x6e;&#x2e;&#99;&#x6f;&#109;。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。 HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 Get请求例子，使用Charles抓取的request： 1234567GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request： 12345678POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。例子 12345678910HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的第四部分：响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常见状态码： 12345678200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 更多状态码http://www.runoob.com/http/http-status-codes.html HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接; 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放 TCP连接; 6、浏览器将该 html 文本并显示内容; GET和POST请求的区别GET请求 123456GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive注意最后一行是空行 POST请求 123456789POST / HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；例 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET：特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。 因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST：由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3、安全性 POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为：(1)登录页面有可能被浏览器缓存；(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击 4、Http get,post,soap协议都是在http上运行的 （1）get：请求参数是作为一个key/value对的序列（查询字符串）附加到URL上的查询字符串的长度受到web浏览器和web服务器的限制（如IE最多支持2048个字符），不适合传输大型数据集同时，它很不安全 （2）post：请求参数是在http标题的一个不同部分（名为entity body）传输的，这一部分用来传输表单信息，因此必须将Content-type设置为:application/x-www-form- urlencoded。post设计用来支持web窗体上的用户字段，其参数也是作为key/value对传输。但是：它不支持复杂数据类型，因为post没有定义传输数据结构的语义和规则。 （3）soap：是http post的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml 任何数据都可以xml化。 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. GET和POST的区别 1.GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. 2.GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. 3.GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 4.GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://www.milla.club/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"纯CSS实现水平轮播效果","slug":"纯CSS实现水平轮播效果","date":"2019-04-19T10:15:45.000Z","updated":"2020-04-21T06:19:03.057Z","comments":true,"path":"2019/04/19/纯CSS实现水平轮播效果/","link":"","permalink":"http://www.milla.club/2019/04/19/%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E8%BD%AE%E6%92%AD%E6%95%88%E6%9E%9C/","excerpt":"以下为只使用CSS实现水平轮播效果代码。","text":"以下为只使用CSS实现水平轮播效果代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; #list &#123; width: 5464px; height: 768px; &#125; #box &#123; position: relative; width: 1366px; height: 768px; border: 1px solid #000000; &#125; #list img &#123; float: left; &#125; #btn &#123; position: absolute; right: 10px; bottom: 15px; &#125; #btn a &#123; float: left; width: 30px; height: 30px; border: 1px solid #000000; margin-right: 5px; text-align: center; line-height: 30px; text-decoration: none; background: rgba(0, 0, 0, .5); color: white; &#125; #btn a:hover &#123; background: #000000; &#125; #box2 &#123; width: 1366px; height: 768px; overflow: hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;btn&quot;&gt; &lt;a href=&quot;#img1&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;#img2&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;#img3&quot;&gt;3&lt;/a&gt; &lt;a href=&quot;#img4&quot;&gt;4&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;box2&quot;&gt; &lt;div id=&quot;list&quot;&gt; &lt;img id=&quot;img1&quot; src=&quot;./imgs/img (1).jpg&quot; /&gt; &lt;img id=&quot;img2&quot; src=&quot;./imgs/img (2).jpg&quot; /&gt; &lt;img id=&quot;img3&quot; src=&quot;./imgs/img (3).jpg&quot; /&gt; &lt;img id=&quot;img4&quot; src=&quot;./imgs/img (4).jpg&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 图片若有侵权，请联系进行删除。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.milla.club/tags/CSS/"}]}],"categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.milla.club/categories/Docker/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.milla.club/categories/JavaScript/"}],"tags":[{"name":"Dcoker","slug":"Dcoker","permalink":"http://www.milla.club/tags/Dcoker/"},{"name":"Linux","slug":"Linux","permalink":"http://www.milla.club/tags/Linux/"},{"name":"Node","slug":"Node","permalink":"http://www.milla.club/tags/Node/"},{"name":"npm","slug":"npm","permalink":"http://www.milla.club/tags/npm/"},{"name":"CSS","slug":"CSS","permalink":"http://www.milla.club/tags/CSS/"},{"name":"Less","slug":"Less","permalink":"http://www.milla.club/tags/Less/"},{"name":"Sass","slug":"Sass","permalink":"http://www.milla.club/tags/Sass/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.milla.club/tags/JavaScript/"},{"name":"Python","slug":"Python","permalink":"http://www.milla.club/tags/Python/"},{"name":"WEB","slug":"WEB","permalink":"http://www.milla.club/tags/WEB/"},{"name":"HTML","slug":"HTML","permalink":"http://www.milla.club/tags/HTML/"},{"name":"网络协议","slug":"网络协议","permalink":"http://www.milla.club/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]}